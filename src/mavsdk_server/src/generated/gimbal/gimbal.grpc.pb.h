// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: gimbal/gimbal.proto
#ifndef GRPC_gimbal_2fgimbal_2eproto__INCLUDED
#define GRPC_gimbal_2fgimbal_2eproto__INCLUDED

#include "gimbal/gimbal.pb.h"

#include <functional>
#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace mavsdk {
namespace rpc {
namespace gimbal {

// Provide control over a gimbal.
class GimbalService final {
public:
    static constexpr char const* service_full_name() { return "mavsdk.rpc.gimbal.GimbalService"; }
    class StubInterface {
    public:
        virtual ~StubInterface() {}
        //
        //
        // Set gimbal pitch and yaw angles.
        //
        // This sets the desired pitch and yaw angles of a gimbal.
        // Will return when the command is accepted, however, it might
        // take the gimbal longer to actually be set to the new angles.
        virtual ::grpc::Status SetPitchAndYaw(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::SetPitchAndYawRequest& request,
            ::mavsdk::rpc::gimbal::SetPitchAndYawResponse* response) = 0;
        std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
            ::mavsdk::rpc::gimbal::SetPitchAndYawResponse>>
        AsyncSetPitchAndYaw(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::SetPitchAndYawRequest& request,
            ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
                ::mavsdk::rpc::gimbal::SetPitchAndYawResponse>>(
                AsyncSetPitchAndYawRaw(context, request, cq));
        }
        std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
            ::mavsdk::rpc::gimbal::SetPitchAndYawResponse>>
        PrepareAsyncSetPitchAndYaw(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::SetPitchAndYawRequest& request,
            ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
                ::mavsdk::rpc::gimbal::SetPitchAndYawResponse>>(
                PrepareAsyncSetPitchAndYawRaw(context, request, cq));
        }
        //
        //
        // Set gimbal angular rates around pitch and yaw axes.
        //
        // This sets the desired angular rates around pitch and yaw axes of a gimbal.
        // Will return when the command is accepted, however, it might
        // take the gimbal longer to actually reach the angular rate.
        virtual ::grpc::Status SetPitchRateAndYawRate(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateRequest& request,
            ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateResponse* response) = 0;
        std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
            ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateResponse>>
        AsyncSetPitchRateAndYawRate(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateRequest& request,
            ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
                ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateResponse>>(
                AsyncSetPitchRateAndYawRateRaw(context, request, cq));
        }
        std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
            ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateResponse>>
        PrepareAsyncSetPitchRateAndYawRate(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateRequest& request,
            ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
                ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateResponse>>(
                PrepareAsyncSetPitchRateAndYawRateRaw(context, request, cq));
        }
        //
        // Set gimbal mode.
        //
        // This sets the desired yaw mode of a gimbal.
        // Will return when the command is accepted. However, it might
        // take the gimbal longer to actually be set to the new angles.
        virtual ::grpc::Status SetMode(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::SetModeRequest& request,
            ::mavsdk::rpc::gimbal::SetModeResponse* response) = 0;
        std::unique_ptr<
            ::grpc::ClientAsyncResponseReaderInterface<::mavsdk::rpc::gimbal::SetModeResponse>>
        AsyncSetMode(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::SetModeRequest& request,
            ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr<
                ::grpc::ClientAsyncResponseReaderInterface<::mavsdk::rpc::gimbal::SetModeResponse>>(
                AsyncSetModeRaw(context, request, cq));
        }
        std::unique_ptr<
            ::grpc::ClientAsyncResponseReaderInterface<::mavsdk::rpc::gimbal::SetModeResponse>>
        PrepareAsyncSetMode(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::SetModeRequest& request,
            ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr<
                ::grpc::ClientAsyncResponseReaderInterface<::mavsdk::rpc::gimbal::SetModeResponse>>(
                PrepareAsyncSetModeRaw(context, request, cq));
        }
        //
        // Set gimbal region of interest (ROI).
        //
        // This sets a region of interest that the gimbal will point to.
        // The gimbal will continue to point to the specified region until it
        // receives a new command.
        // The function will return when the command is accepted, however, it might
        // take the gimbal longer to actually rotate to the ROI.
        virtual ::grpc::Status SetRoiLocation(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::SetRoiLocationRequest& request,
            ::mavsdk::rpc::gimbal::SetRoiLocationResponse* response) = 0;
        std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
            ::mavsdk::rpc::gimbal::SetRoiLocationResponse>>
        AsyncSetRoiLocation(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::SetRoiLocationRequest& request,
            ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
                ::mavsdk::rpc::gimbal::SetRoiLocationResponse>>(
                AsyncSetRoiLocationRaw(context, request, cq));
        }
        std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
            ::mavsdk::rpc::gimbal::SetRoiLocationResponse>>
        PrepareAsyncSetRoiLocation(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::SetRoiLocationRequest& request,
            ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
                ::mavsdk::rpc::gimbal::SetRoiLocationResponse>>(
                PrepareAsyncSetRoiLocationRaw(context, request, cq));
        }
        //
        // Take control.
        //
        // There can be only two components in control of a gimbal at any given time.
        // One with "primary" control, and one with "secondary" control. The way the
        // secondary control is implemented is not specified and hence depends on the
        // vehicle.
        //
        // Components are expected to be cooperative, which means that they can
        // override each other and should therefore do it carefully.
        virtual ::grpc::Status TakeControl(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::TakeControlRequest& request,
            ::mavsdk::rpc::gimbal::TakeControlResponse* response) = 0;
        std::unique_ptr<
            ::grpc::ClientAsyncResponseReaderInterface<::mavsdk::rpc::gimbal::TakeControlResponse>>
        AsyncTakeControl(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::TakeControlRequest& request,
            ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
                ::mavsdk::rpc::gimbal::TakeControlResponse>>(
                AsyncTakeControlRaw(context, request, cq));
        }
        std::unique_ptr<
            ::grpc::ClientAsyncResponseReaderInterface<::mavsdk::rpc::gimbal::TakeControlResponse>>
        PrepareAsyncTakeControl(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::TakeControlRequest& request,
            ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
                ::mavsdk::rpc::gimbal::TakeControlResponse>>(
                PrepareAsyncTakeControlRaw(context, request, cq));
        }
        //
        // Release control.
        //
        // Release control, such that other components can control the gimbal.
        virtual ::grpc::Status ReleaseControl(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::ReleaseControlRequest& request,
            ::mavsdk::rpc::gimbal::ReleaseControlResponse* response) = 0;
        std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
            ::mavsdk::rpc::gimbal::ReleaseControlResponse>>
        AsyncReleaseControl(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::ReleaseControlRequest& request,
            ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
                ::mavsdk::rpc::gimbal::ReleaseControlResponse>>(
                AsyncReleaseControlRaw(context, request, cq));
        }
        std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
            ::mavsdk::rpc::gimbal::ReleaseControlResponse>>
        PrepareAsyncReleaseControl(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::ReleaseControlRequest& request,
            ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
                ::mavsdk::rpc::gimbal::ReleaseControlResponse>>(
                PrepareAsyncReleaseControlRaw(context, request, cq));
        }
        //
        // Subscribe to control status updates.
        //
        // This allows a component to know if it has primary, secondary or
        // no control over the gimbal. Also, it gives the system and component ids
        // of the other components in control (if any).
        std::unique_ptr<::grpc::ClientReaderInterface<::mavsdk::rpc::gimbal::ControlResponse>>
        SubscribeControl(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::SubscribeControlRequest& request)
        {
            return std::unique_ptr<
                ::grpc::ClientReaderInterface<::mavsdk::rpc::gimbal::ControlResponse>>(
                SubscribeControlRaw(context, request));
        }
        std::unique_ptr<::grpc::ClientAsyncReaderInterface<::mavsdk::rpc::gimbal::ControlResponse>>
        AsyncSubscribeControl(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::SubscribeControlRequest& request,
            ::grpc::CompletionQueue* cq,
            void* tag)
        {
            return std::unique_ptr<
                ::grpc::ClientAsyncReaderInterface<::mavsdk::rpc::gimbal::ControlResponse>>(
                AsyncSubscribeControlRaw(context, request, cq, tag));
        }
        std::unique_ptr<::grpc::ClientAsyncReaderInterface<::mavsdk::rpc::gimbal::ControlResponse>>
        PrepareAsyncSubscribeControl(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::SubscribeControlRequest& request,
            ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr<
                ::grpc::ClientAsyncReaderInterface<::mavsdk::rpc::gimbal::ControlResponse>>(
                PrepareAsyncSubscribeControlRaw(context, request, cq));
        }
        class experimental_async_interface {
        public:
            virtual ~experimental_async_interface() {}
            //
            //
            // Set gimbal pitch and yaw angles.
            //
            // This sets the desired pitch and yaw angles of a gimbal.
            // Will return when the command is accepted, however, it might
            // take the gimbal longer to actually be set to the new angles.
            virtual void SetPitchAndYaw(
                ::grpc::ClientContext* context,
                const ::mavsdk::rpc::gimbal::SetPitchAndYawRequest* request,
                ::mavsdk::rpc::gimbal::SetPitchAndYawResponse* response,
                std::function<void(::grpc::Status)>) = 0;
            virtual void SetPitchAndYaw(
                ::grpc::ClientContext* context,
                const ::grpc::ByteBuffer* request,
                ::mavsdk::rpc::gimbal::SetPitchAndYawResponse* response,
                std::function<void(::grpc::Status)>) = 0;
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            virtual void SetPitchAndYaw(
                ::grpc::ClientContext* context,
                const ::mavsdk::rpc::gimbal::SetPitchAndYawRequest* request,
                ::mavsdk::rpc::gimbal::SetPitchAndYawResponse* response,
                ::grpc::ClientUnaryReactor* reactor) = 0;
#else
            virtual void SetPitchAndYaw(
                ::grpc::ClientContext* context,
                const ::mavsdk::rpc::gimbal::SetPitchAndYawRequest* request,
                ::mavsdk::rpc::gimbal::SetPitchAndYawResponse* response,
                ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
#endif
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            virtual void SetPitchAndYaw(
                ::grpc::ClientContext* context,
                const ::grpc::ByteBuffer* request,
                ::mavsdk::rpc::gimbal::SetPitchAndYawResponse* response,
                ::grpc::ClientUnaryReactor* reactor) = 0;
#else
            virtual void SetPitchAndYaw(
                ::grpc::ClientContext* context,
                const ::grpc::ByteBuffer* request,
                ::mavsdk::rpc::gimbal::SetPitchAndYawResponse* response,
                ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
#endif
            //
            //
            // Set gimbal angular rates around pitch and yaw axes.
            //
            // This sets the desired angular rates around pitch and yaw axes of a gimbal.
            // Will return when the command is accepted, however, it might
            // take the gimbal longer to actually reach the angular rate.
            virtual void SetPitchRateAndYawRate(
                ::grpc::ClientContext* context,
                const ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateRequest* request,
                ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateResponse* response,
                std::function<void(::grpc::Status)>) = 0;
            virtual void SetPitchRateAndYawRate(
                ::grpc::ClientContext* context,
                const ::grpc::ByteBuffer* request,
                ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateResponse* response,
                std::function<void(::grpc::Status)>) = 0;
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            virtual void SetPitchRateAndYawRate(
                ::grpc::ClientContext* context,
                const ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateRequest* request,
                ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateResponse* response,
                ::grpc::ClientUnaryReactor* reactor) = 0;
#else
            virtual void SetPitchRateAndYawRate(
                ::grpc::ClientContext* context,
                const ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateRequest* request,
                ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateResponse* response,
                ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
#endif
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            virtual void SetPitchRateAndYawRate(
                ::grpc::ClientContext* context,
                const ::grpc::ByteBuffer* request,
                ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateResponse* response,
                ::grpc::ClientUnaryReactor* reactor) = 0;
#else
            virtual void SetPitchRateAndYawRate(
                ::grpc::ClientContext* context,
                const ::grpc::ByteBuffer* request,
                ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateResponse* response,
                ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
#endif
            //
            // Set gimbal mode.
            //
            // This sets the desired yaw mode of a gimbal.
            // Will return when the command is accepted. However, it might
            // take the gimbal longer to actually be set to the new angles.
            virtual void SetMode(
                ::grpc::ClientContext* context,
                const ::mavsdk::rpc::gimbal::SetModeRequest* request,
                ::mavsdk::rpc::gimbal::SetModeResponse* response,
                std::function<void(::grpc::Status)>) = 0;
            virtual void SetMode(
                ::grpc::ClientContext* context,
                const ::grpc::ByteBuffer* request,
                ::mavsdk::rpc::gimbal::SetModeResponse* response,
                std::function<void(::grpc::Status)>) = 0;
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            virtual void SetMode(
                ::grpc::ClientContext* context,
                const ::mavsdk::rpc::gimbal::SetModeRequest* request,
                ::mavsdk::rpc::gimbal::SetModeResponse* response,
                ::grpc::ClientUnaryReactor* reactor) = 0;
#else
            virtual void SetMode(
                ::grpc::ClientContext* context,
                const ::mavsdk::rpc::gimbal::SetModeRequest* request,
                ::mavsdk::rpc::gimbal::SetModeResponse* response,
                ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
#endif
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            virtual void SetMode(
                ::grpc::ClientContext* context,
                const ::grpc::ByteBuffer* request,
                ::mavsdk::rpc::gimbal::SetModeResponse* response,
                ::grpc::ClientUnaryReactor* reactor) = 0;
#else
            virtual void SetMode(
                ::grpc::ClientContext* context,
                const ::grpc::ByteBuffer* request,
                ::mavsdk::rpc::gimbal::SetModeResponse* response,
                ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
#endif
            //
            // Set gimbal region of interest (ROI).
            //
            // This sets a region of interest that the gimbal will point to.
            // The gimbal will continue to point to the specified region until it
            // receives a new command.
            // The function will return when the command is accepted, however, it might
            // take the gimbal longer to actually rotate to the ROI.
            virtual void SetRoiLocation(
                ::grpc::ClientContext* context,
                const ::mavsdk::rpc::gimbal::SetRoiLocationRequest* request,
                ::mavsdk::rpc::gimbal::SetRoiLocationResponse* response,
                std::function<void(::grpc::Status)>) = 0;
            virtual void SetRoiLocation(
                ::grpc::ClientContext* context,
                const ::grpc::ByteBuffer* request,
                ::mavsdk::rpc::gimbal::SetRoiLocationResponse* response,
                std::function<void(::grpc::Status)>) = 0;
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            virtual void SetRoiLocation(
                ::grpc::ClientContext* context,
                const ::mavsdk::rpc::gimbal::SetRoiLocationRequest* request,
                ::mavsdk::rpc::gimbal::SetRoiLocationResponse* response,
                ::grpc::ClientUnaryReactor* reactor) = 0;
#else
            virtual void SetRoiLocation(
                ::grpc::ClientContext* context,
                const ::mavsdk::rpc::gimbal::SetRoiLocationRequest* request,
                ::mavsdk::rpc::gimbal::SetRoiLocationResponse* response,
                ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
#endif
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            virtual void SetRoiLocation(
                ::grpc::ClientContext* context,
                const ::grpc::ByteBuffer* request,
                ::mavsdk::rpc::gimbal::SetRoiLocationResponse* response,
                ::grpc::ClientUnaryReactor* reactor) = 0;
#else
            virtual void SetRoiLocation(
                ::grpc::ClientContext* context,
                const ::grpc::ByteBuffer* request,
                ::mavsdk::rpc::gimbal::SetRoiLocationResponse* response,
                ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
#endif
            //
            // Take control.
            //
            // There can be only two components in control of a gimbal at any given time.
            // One with "primary" control, and one with "secondary" control. The way the
            // secondary control is implemented is not specified and hence depends on the
            // vehicle.
            //
            // Components are expected to be cooperative, which means that they can
            // override each other and should therefore do it carefully.
            virtual void TakeControl(
                ::grpc::ClientContext* context,
                const ::mavsdk::rpc::gimbal::TakeControlRequest* request,
                ::mavsdk::rpc::gimbal::TakeControlResponse* response,
                std::function<void(::grpc::Status)>) = 0;
            virtual void TakeControl(
                ::grpc::ClientContext* context,
                const ::grpc::ByteBuffer* request,
                ::mavsdk::rpc::gimbal::TakeControlResponse* response,
                std::function<void(::grpc::Status)>) = 0;
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            virtual void TakeControl(
                ::grpc::ClientContext* context,
                const ::mavsdk::rpc::gimbal::TakeControlRequest* request,
                ::mavsdk::rpc::gimbal::TakeControlResponse* response,
                ::grpc::ClientUnaryReactor* reactor) = 0;
#else
            virtual void TakeControl(
                ::grpc::ClientContext* context,
                const ::mavsdk::rpc::gimbal::TakeControlRequest* request,
                ::mavsdk::rpc::gimbal::TakeControlResponse* response,
                ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
#endif
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            virtual void TakeControl(
                ::grpc::ClientContext* context,
                const ::grpc::ByteBuffer* request,
                ::mavsdk::rpc::gimbal::TakeControlResponse* response,
                ::grpc::ClientUnaryReactor* reactor) = 0;
#else
            virtual void TakeControl(
                ::grpc::ClientContext* context,
                const ::grpc::ByteBuffer* request,
                ::mavsdk::rpc::gimbal::TakeControlResponse* response,
                ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
#endif
            //
            // Release control.
            //
            // Release control, such that other components can control the gimbal.
            virtual void ReleaseControl(
                ::grpc::ClientContext* context,
                const ::mavsdk::rpc::gimbal::ReleaseControlRequest* request,
                ::mavsdk::rpc::gimbal::ReleaseControlResponse* response,
                std::function<void(::grpc::Status)>) = 0;
            virtual void ReleaseControl(
                ::grpc::ClientContext* context,
                const ::grpc::ByteBuffer* request,
                ::mavsdk::rpc::gimbal::ReleaseControlResponse* response,
                std::function<void(::grpc::Status)>) = 0;
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            virtual void ReleaseControl(
                ::grpc::ClientContext* context,
                const ::mavsdk::rpc::gimbal::ReleaseControlRequest* request,
                ::mavsdk::rpc::gimbal::ReleaseControlResponse* response,
                ::grpc::ClientUnaryReactor* reactor) = 0;
#else
            virtual void ReleaseControl(
                ::grpc::ClientContext* context,
                const ::mavsdk::rpc::gimbal::ReleaseControlRequest* request,
                ::mavsdk::rpc::gimbal::ReleaseControlResponse* response,
                ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
#endif
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            virtual void ReleaseControl(
                ::grpc::ClientContext* context,
                const ::grpc::ByteBuffer* request,
                ::mavsdk::rpc::gimbal::ReleaseControlResponse* response,
                ::grpc::ClientUnaryReactor* reactor) = 0;
#else
            virtual void ReleaseControl(
                ::grpc::ClientContext* context,
                const ::grpc::ByteBuffer* request,
                ::mavsdk::rpc::gimbal::ReleaseControlResponse* response,
                ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
#endif
//
// Subscribe to control status updates.
//
// This allows a component to know if it has primary, secondary or
// no control over the gimbal. Also, it gives the system and component ids
// of the other components in control (if any).
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            virtual void SubscribeControl(
                ::grpc::ClientContext* context,
                ::mavsdk::rpc::gimbal::SubscribeControlRequest* request,
                ::grpc::ClientReadReactor<::mavsdk::rpc::gimbal::ControlResponse>* reactor) = 0;
#else
            virtual void SubscribeControl(
                ::grpc::ClientContext* context,
                ::mavsdk::rpc::gimbal::SubscribeControlRequest* request,
                ::grpc::experimental::ClientReadReactor<::mavsdk::rpc::gimbal::ControlResponse>*
                    reactor) = 0;
#endif
        };
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        typedef class experimental_async_interface async_interface;
#endif
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        async_interface* async() { return experimental_async(); }
#endif
        virtual class experimental_async_interface* experimental_async() { return nullptr; }

    private:
        virtual ::grpc::ClientAsyncResponseReaderInterface<
            ::mavsdk::rpc::gimbal::SetPitchAndYawResponse>*
        AsyncSetPitchAndYawRaw(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::SetPitchAndYawRequest& request,
            ::grpc::CompletionQueue* cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface<
            ::mavsdk::rpc::gimbal::SetPitchAndYawResponse>*
        PrepareAsyncSetPitchAndYawRaw(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::SetPitchAndYawRequest& request,
            ::grpc::CompletionQueue* cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface<
            ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateResponse>*
        AsyncSetPitchRateAndYawRateRaw(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateRequest& request,
            ::grpc::CompletionQueue* cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface<
            ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateResponse>*
        PrepareAsyncSetPitchRateAndYawRateRaw(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateRequest& request,
            ::grpc::CompletionQueue* cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface<::mavsdk::rpc::gimbal::SetModeResponse>*
        AsyncSetModeRaw(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::SetModeRequest& request,
            ::grpc::CompletionQueue* cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface<::mavsdk::rpc::gimbal::SetModeResponse>*
        PrepareAsyncSetModeRaw(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::SetModeRequest& request,
            ::grpc::CompletionQueue* cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface<
            ::mavsdk::rpc::gimbal::SetRoiLocationResponse>*
        AsyncSetRoiLocationRaw(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::SetRoiLocationRequest& request,
            ::grpc::CompletionQueue* cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface<
            ::mavsdk::rpc::gimbal::SetRoiLocationResponse>*
        PrepareAsyncSetRoiLocationRaw(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::SetRoiLocationRequest& request,
            ::grpc::CompletionQueue* cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface<
            ::mavsdk::rpc::gimbal::TakeControlResponse>*
        AsyncTakeControlRaw(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::TakeControlRequest& request,
            ::grpc::CompletionQueue* cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface<
            ::mavsdk::rpc::gimbal::TakeControlResponse>*
        PrepareAsyncTakeControlRaw(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::TakeControlRequest& request,
            ::grpc::CompletionQueue* cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface<
            ::mavsdk::rpc::gimbal::ReleaseControlResponse>*
        AsyncReleaseControlRaw(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::ReleaseControlRequest& request,
            ::grpc::CompletionQueue* cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface<
            ::mavsdk::rpc::gimbal::ReleaseControlResponse>*
        PrepareAsyncReleaseControlRaw(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::ReleaseControlRequest& request,
            ::grpc::CompletionQueue* cq) = 0;
        virtual ::grpc::ClientReaderInterface<::mavsdk::rpc::gimbal::ControlResponse>*
        SubscribeControlRaw(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::SubscribeControlRequest& request) = 0;
        virtual ::grpc::ClientAsyncReaderInterface<::mavsdk::rpc::gimbal::ControlResponse>*
        AsyncSubscribeControlRaw(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::SubscribeControlRequest& request,
            ::grpc::CompletionQueue* cq,
            void* tag) = 0;
        virtual ::grpc::ClientAsyncReaderInterface<::mavsdk::rpc::gimbal::ControlResponse>*
        PrepareAsyncSubscribeControlRaw(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::SubscribeControlRequest& request,
            ::grpc::CompletionQueue* cq) = 0;
    };
    class Stub final : public StubInterface {
    public:
        Stub(const std::shared_ptr<::grpc::ChannelInterface>& channel);
        ::grpc::Status SetPitchAndYaw(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::SetPitchAndYawRequest& request,
            ::mavsdk::rpc::gimbal::SetPitchAndYawResponse* response) override;
        std::unique_ptr<
            ::grpc::ClientAsyncResponseReader<::mavsdk::rpc::gimbal::SetPitchAndYawResponse>>
        AsyncSetPitchAndYaw(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::SetPitchAndYawRequest& request,
            ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr<
                ::grpc::ClientAsyncResponseReader<::mavsdk::rpc::gimbal::SetPitchAndYawResponse>>(
                AsyncSetPitchAndYawRaw(context, request, cq));
        }
        std::unique_ptr<
            ::grpc::ClientAsyncResponseReader<::mavsdk::rpc::gimbal::SetPitchAndYawResponse>>
        PrepareAsyncSetPitchAndYaw(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::SetPitchAndYawRequest& request,
            ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr<
                ::grpc::ClientAsyncResponseReader<::mavsdk::rpc::gimbal::SetPitchAndYawResponse>>(
                PrepareAsyncSetPitchAndYawRaw(context, request, cq));
        }
        ::grpc::Status SetPitchRateAndYawRate(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateRequest& request,
            ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateResponse* response) override;
        std::unique_ptr<::grpc::ClientAsyncResponseReader<
            ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateResponse>>
        AsyncSetPitchRateAndYawRate(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateRequest& request,
            ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr<::grpc::ClientAsyncResponseReader<
                ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateResponse>>(
                AsyncSetPitchRateAndYawRateRaw(context, request, cq));
        }
        std::unique_ptr<::grpc::ClientAsyncResponseReader<
            ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateResponse>>
        PrepareAsyncSetPitchRateAndYawRate(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateRequest& request,
            ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr<::grpc::ClientAsyncResponseReader<
                ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateResponse>>(
                PrepareAsyncSetPitchRateAndYawRateRaw(context, request, cq));
        }
        ::grpc::Status SetMode(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::SetModeRequest& request,
            ::mavsdk::rpc::gimbal::SetModeResponse* response) override;
        std::unique_ptr<::grpc::ClientAsyncResponseReader<::mavsdk::rpc::gimbal::SetModeResponse>>
        AsyncSetMode(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::SetModeRequest& request,
            ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr<
                ::grpc::ClientAsyncResponseReader<::mavsdk::rpc::gimbal::SetModeResponse>>(
                AsyncSetModeRaw(context, request, cq));
        }
        std::unique_ptr<::grpc::ClientAsyncResponseReader<::mavsdk::rpc::gimbal::SetModeResponse>>
        PrepareAsyncSetMode(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::SetModeRequest& request,
            ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr<
                ::grpc::ClientAsyncResponseReader<::mavsdk::rpc::gimbal::SetModeResponse>>(
                PrepareAsyncSetModeRaw(context, request, cq));
        }
        ::grpc::Status SetRoiLocation(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::SetRoiLocationRequest& request,
            ::mavsdk::rpc::gimbal::SetRoiLocationResponse* response) override;
        std::unique_ptr<
            ::grpc::ClientAsyncResponseReader<::mavsdk::rpc::gimbal::SetRoiLocationResponse>>
        AsyncSetRoiLocation(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::SetRoiLocationRequest& request,
            ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr<
                ::grpc::ClientAsyncResponseReader<::mavsdk::rpc::gimbal::SetRoiLocationResponse>>(
                AsyncSetRoiLocationRaw(context, request, cq));
        }
        std::unique_ptr<
            ::grpc::ClientAsyncResponseReader<::mavsdk::rpc::gimbal::SetRoiLocationResponse>>
        PrepareAsyncSetRoiLocation(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::SetRoiLocationRequest& request,
            ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr<
                ::grpc::ClientAsyncResponseReader<::mavsdk::rpc::gimbal::SetRoiLocationResponse>>(
                PrepareAsyncSetRoiLocationRaw(context, request, cq));
        }
        ::grpc::Status TakeControl(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::TakeControlRequest& request,
            ::mavsdk::rpc::gimbal::TakeControlResponse* response) override;
        std::unique_ptr<
            ::grpc::ClientAsyncResponseReader<::mavsdk::rpc::gimbal::TakeControlResponse>>
        AsyncTakeControl(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::TakeControlRequest& request,
            ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr<
                ::grpc::ClientAsyncResponseReader<::mavsdk::rpc::gimbal::TakeControlResponse>>(
                AsyncTakeControlRaw(context, request, cq));
        }
        std::unique_ptr<
            ::grpc::ClientAsyncResponseReader<::mavsdk::rpc::gimbal::TakeControlResponse>>
        PrepareAsyncTakeControl(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::TakeControlRequest& request,
            ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr<
                ::grpc::ClientAsyncResponseReader<::mavsdk::rpc::gimbal::TakeControlResponse>>(
                PrepareAsyncTakeControlRaw(context, request, cq));
        }
        ::grpc::Status ReleaseControl(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::ReleaseControlRequest& request,
            ::mavsdk::rpc::gimbal::ReleaseControlResponse* response) override;
        std::unique_ptr<
            ::grpc::ClientAsyncResponseReader<::mavsdk::rpc::gimbal::ReleaseControlResponse>>
        AsyncReleaseControl(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::ReleaseControlRequest& request,
            ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr<
                ::grpc::ClientAsyncResponseReader<::mavsdk::rpc::gimbal::ReleaseControlResponse>>(
                AsyncReleaseControlRaw(context, request, cq));
        }
        std::unique_ptr<
            ::grpc::ClientAsyncResponseReader<::mavsdk::rpc::gimbal::ReleaseControlResponse>>
        PrepareAsyncReleaseControl(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::ReleaseControlRequest& request,
            ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr<
                ::grpc::ClientAsyncResponseReader<::mavsdk::rpc::gimbal::ReleaseControlResponse>>(
                PrepareAsyncReleaseControlRaw(context, request, cq));
        }
        std::unique_ptr<::grpc::ClientReader<::mavsdk::rpc::gimbal::ControlResponse>>
        SubscribeControl(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::SubscribeControlRequest& request)
        {
            return std::unique_ptr<::grpc::ClientReader<::mavsdk::rpc::gimbal::ControlResponse>>(
                SubscribeControlRaw(context, request));
        }
        std::unique_ptr<::grpc::ClientAsyncReader<::mavsdk::rpc::gimbal::ControlResponse>>
        AsyncSubscribeControl(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::SubscribeControlRequest& request,
            ::grpc::CompletionQueue* cq,
            void* tag)
        {
            return std::unique_ptr<
                ::grpc::ClientAsyncReader<::mavsdk::rpc::gimbal::ControlResponse>>(
                AsyncSubscribeControlRaw(context, request, cq, tag));
        }
        std::unique_ptr<::grpc::ClientAsyncReader<::mavsdk::rpc::gimbal::ControlResponse>>
        PrepareAsyncSubscribeControl(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::SubscribeControlRequest& request,
            ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr<
                ::grpc::ClientAsyncReader<::mavsdk::rpc::gimbal::ControlResponse>>(
                PrepareAsyncSubscribeControlRaw(context, request, cq));
        }
        class experimental_async final : public StubInterface::experimental_async_interface {
        public:
            void SetPitchAndYaw(
                ::grpc::ClientContext* context,
                const ::mavsdk::rpc::gimbal::SetPitchAndYawRequest* request,
                ::mavsdk::rpc::gimbal::SetPitchAndYawResponse* response,
                std::function<void(::grpc::Status)>) override;
            void SetPitchAndYaw(
                ::grpc::ClientContext* context,
                const ::grpc::ByteBuffer* request,
                ::mavsdk::rpc::gimbal::SetPitchAndYawResponse* response,
                std::function<void(::grpc::Status)>) override;
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            void SetPitchAndYaw(
                ::grpc::ClientContext* context,
                const ::mavsdk::rpc::gimbal::SetPitchAndYawRequest* request,
                ::mavsdk::rpc::gimbal::SetPitchAndYawResponse* response,
                ::grpc::ClientUnaryReactor* reactor) override;
#else
            void SetPitchAndYaw(
                ::grpc::ClientContext* context,
                const ::mavsdk::rpc::gimbal::SetPitchAndYawRequest* request,
                ::mavsdk::rpc::gimbal::SetPitchAndYawResponse* response,
                ::grpc::experimental::ClientUnaryReactor* reactor) override;
#endif
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            void SetPitchAndYaw(
                ::grpc::ClientContext* context,
                const ::grpc::ByteBuffer* request,
                ::mavsdk::rpc::gimbal::SetPitchAndYawResponse* response,
                ::grpc::ClientUnaryReactor* reactor) override;
#else
            void SetPitchAndYaw(
                ::grpc::ClientContext* context,
                const ::grpc::ByteBuffer* request,
                ::mavsdk::rpc::gimbal::SetPitchAndYawResponse* response,
                ::grpc::experimental::ClientUnaryReactor* reactor) override;
#endif
            void SetPitchRateAndYawRate(
                ::grpc::ClientContext* context,
                const ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateRequest* request,
                ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateResponse* response,
                std::function<void(::grpc::Status)>) override;
            void SetPitchRateAndYawRate(
                ::grpc::ClientContext* context,
                const ::grpc::ByteBuffer* request,
                ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateResponse* response,
                std::function<void(::grpc::Status)>) override;
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            void SetPitchRateAndYawRate(
                ::grpc::ClientContext* context,
                const ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateRequest* request,
                ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateResponse* response,
                ::grpc::ClientUnaryReactor* reactor) override;
#else
            void SetPitchRateAndYawRate(
                ::grpc::ClientContext* context,
                const ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateRequest* request,
                ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateResponse* response,
                ::grpc::experimental::ClientUnaryReactor* reactor) override;
#endif
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            void SetPitchRateAndYawRate(
                ::grpc::ClientContext* context,
                const ::grpc::ByteBuffer* request,
                ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateResponse* response,
                ::grpc::ClientUnaryReactor* reactor) override;
#else
            void SetPitchRateAndYawRate(
                ::grpc::ClientContext* context,
                const ::grpc::ByteBuffer* request,
                ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateResponse* response,
                ::grpc::experimental::ClientUnaryReactor* reactor) override;
#endif
            void SetMode(
                ::grpc::ClientContext* context,
                const ::mavsdk::rpc::gimbal::SetModeRequest* request,
                ::mavsdk::rpc::gimbal::SetModeResponse* response,
                std::function<void(::grpc::Status)>) override;
            void SetMode(
                ::grpc::ClientContext* context,
                const ::grpc::ByteBuffer* request,
                ::mavsdk::rpc::gimbal::SetModeResponse* response,
                std::function<void(::grpc::Status)>) override;
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            void SetMode(
                ::grpc::ClientContext* context,
                const ::mavsdk::rpc::gimbal::SetModeRequest* request,
                ::mavsdk::rpc::gimbal::SetModeResponse* response,
                ::grpc::ClientUnaryReactor* reactor) override;
#else
            void SetMode(
                ::grpc::ClientContext* context,
                const ::mavsdk::rpc::gimbal::SetModeRequest* request,
                ::mavsdk::rpc::gimbal::SetModeResponse* response,
                ::grpc::experimental::ClientUnaryReactor* reactor) override;
#endif
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            void SetMode(
                ::grpc::ClientContext* context,
                const ::grpc::ByteBuffer* request,
                ::mavsdk::rpc::gimbal::SetModeResponse* response,
                ::grpc::ClientUnaryReactor* reactor) override;
#else
            void SetMode(
                ::grpc::ClientContext* context,
                const ::grpc::ByteBuffer* request,
                ::mavsdk::rpc::gimbal::SetModeResponse* response,
                ::grpc::experimental::ClientUnaryReactor* reactor) override;
#endif
            void SetRoiLocation(
                ::grpc::ClientContext* context,
                const ::mavsdk::rpc::gimbal::SetRoiLocationRequest* request,
                ::mavsdk::rpc::gimbal::SetRoiLocationResponse* response,
                std::function<void(::grpc::Status)>) override;
            void SetRoiLocation(
                ::grpc::ClientContext* context,
                const ::grpc::ByteBuffer* request,
                ::mavsdk::rpc::gimbal::SetRoiLocationResponse* response,
                std::function<void(::grpc::Status)>) override;
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            void SetRoiLocation(
                ::grpc::ClientContext* context,
                const ::mavsdk::rpc::gimbal::SetRoiLocationRequest* request,
                ::mavsdk::rpc::gimbal::SetRoiLocationResponse* response,
                ::grpc::ClientUnaryReactor* reactor) override;
#else
            void SetRoiLocation(
                ::grpc::ClientContext* context,
                const ::mavsdk::rpc::gimbal::SetRoiLocationRequest* request,
                ::mavsdk::rpc::gimbal::SetRoiLocationResponse* response,
                ::grpc::experimental::ClientUnaryReactor* reactor) override;
#endif
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            void SetRoiLocation(
                ::grpc::ClientContext* context,
                const ::grpc::ByteBuffer* request,
                ::mavsdk::rpc::gimbal::SetRoiLocationResponse* response,
                ::grpc::ClientUnaryReactor* reactor) override;
#else
            void SetRoiLocation(
                ::grpc::ClientContext* context,
                const ::grpc::ByteBuffer* request,
                ::mavsdk::rpc::gimbal::SetRoiLocationResponse* response,
                ::grpc::experimental::ClientUnaryReactor* reactor) override;
#endif
            void TakeControl(
                ::grpc::ClientContext* context,
                const ::mavsdk::rpc::gimbal::TakeControlRequest* request,
                ::mavsdk::rpc::gimbal::TakeControlResponse* response,
                std::function<void(::grpc::Status)>) override;
            void TakeControl(
                ::grpc::ClientContext* context,
                const ::grpc::ByteBuffer* request,
                ::mavsdk::rpc::gimbal::TakeControlResponse* response,
                std::function<void(::grpc::Status)>) override;
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            void TakeControl(
                ::grpc::ClientContext* context,
                const ::mavsdk::rpc::gimbal::TakeControlRequest* request,
                ::mavsdk::rpc::gimbal::TakeControlResponse* response,
                ::grpc::ClientUnaryReactor* reactor) override;
#else
            void TakeControl(
                ::grpc::ClientContext* context,
                const ::mavsdk::rpc::gimbal::TakeControlRequest* request,
                ::mavsdk::rpc::gimbal::TakeControlResponse* response,
                ::grpc::experimental::ClientUnaryReactor* reactor) override;
#endif
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            void TakeControl(
                ::grpc::ClientContext* context,
                const ::grpc::ByteBuffer* request,
                ::mavsdk::rpc::gimbal::TakeControlResponse* response,
                ::grpc::ClientUnaryReactor* reactor) override;
#else
            void TakeControl(
                ::grpc::ClientContext* context,
                const ::grpc::ByteBuffer* request,
                ::mavsdk::rpc::gimbal::TakeControlResponse* response,
                ::grpc::experimental::ClientUnaryReactor* reactor) override;
#endif
            void ReleaseControl(
                ::grpc::ClientContext* context,
                const ::mavsdk::rpc::gimbal::ReleaseControlRequest* request,
                ::mavsdk::rpc::gimbal::ReleaseControlResponse* response,
                std::function<void(::grpc::Status)>) override;
            void ReleaseControl(
                ::grpc::ClientContext* context,
                const ::grpc::ByteBuffer* request,
                ::mavsdk::rpc::gimbal::ReleaseControlResponse* response,
                std::function<void(::grpc::Status)>) override;
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            void ReleaseControl(
                ::grpc::ClientContext* context,
                const ::mavsdk::rpc::gimbal::ReleaseControlRequest* request,
                ::mavsdk::rpc::gimbal::ReleaseControlResponse* response,
                ::grpc::ClientUnaryReactor* reactor) override;
#else
            void ReleaseControl(
                ::grpc::ClientContext* context,
                const ::mavsdk::rpc::gimbal::ReleaseControlRequest* request,
                ::mavsdk::rpc::gimbal::ReleaseControlResponse* response,
                ::grpc::experimental::ClientUnaryReactor* reactor) override;
#endif
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            void ReleaseControl(
                ::grpc::ClientContext* context,
                const ::grpc::ByteBuffer* request,
                ::mavsdk::rpc::gimbal::ReleaseControlResponse* response,
                ::grpc::ClientUnaryReactor* reactor) override;
#else
            void ReleaseControl(
                ::grpc::ClientContext* context,
                const ::grpc::ByteBuffer* request,
                ::mavsdk::rpc::gimbal::ReleaseControlResponse* response,
                ::grpc::experimental::ClientUnaryReactor* reactor) override;
#endif
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            void SubscribeControl(
                ::grpc::ClientContext* context,
                ::mavsdk::rpc::gimbal::SubscribeControlRequest* request,
                ::grpc::ClientReadReactor<::mavsdk::rpc::gimbal::ControlResponse>* reactor)
                override;
#else
            void SubscribeControl(
                ::grpc::ClientContext* context,
                ::mavsdk::rpc::gimbal::SubscribeControlRequest* request,
                ::grpc::experimental::ClientReadReactor<::mavsdk::rpc::gimbal::ControlResponse>*
                    reactor) override;
#endif
        private:
            friend class Stub;
            explicit experimental_async(Stub* stub) : stub_(stub) {}
            Stub* stub() { return stub_; }
            Stub* stub_;
        };
        class experimental_async_interface* experimental_async() override { return &async_stub_; }

    private:
        std::shared_ptr<::grpc::ChannelInterface> channel_;
        class experimental_async async_stub_ {
            this
        };
        ::grpc::ClientAsyncResponseReader<::mavsdk::rpc::gimbal::SetPitchAndYawResponse>*
        AsyncSetPitchAndYawRaw(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::SetPitchAndYawRequest& request,
            ::grpc::CompletionQueue* cq) override;
        ::grpc::ClientAsyncResponseReader<::mavsdk::rpc::gimbal::SetPitchAndYawResponse>*
        PrepareAsyncSetPitchAndYawRaw(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::SetPitchAndYawRequest& request,
            ::grpc::CompletionQueue* cq) override;
        ::grpc::ClientAsyncResponseReader<::mavsdk::rpc::gimbal::SetPitchRateAndYawRateResponse>*
        AsyncSetPitchRateAndYawRateRaw(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateRequest& request,
            ::grpc::CompletionQueue* cq) override;
        ::grpc::ClientAsyncResponseReader<::mavsdk::rpc::gimbal::SetPitchRateAndYawRateResponse>*
        PrepareAsyncSetPitchRateAndYawRateRaw(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateRequest& request,
            ::grpc::CompletionQueue* cq) override;
        ::grpc::ClientAsyncResponseReader<::mavsdk::rpc::gimbal::SetModeResponse>* AsyncSetModeRaw(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::SetModeRequest& request,
            ::grpc::CompletionQueue* cq) override;
        ::grpc::ClientAsyncResponseReader<::mavsdk::rpc::gimbal::SetModeResponse>*
        PrepareAsyncSetModeRaw(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::SetModeRequest& request,
            ::grpc::CompletionQueue* cq) override;
        ::grpc::ClientAsyncResponseReader<::mavsdk::rpc::gimbal::SetRoiLocationResponse>*
        AsyncSetRoiLocationRaw(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::SetRoiLocationRequest& request,
            ::grpc::CompletionQueue* cq) override;
        ::grpc::ClientAsyncResponseReader<::mavsdk::rpc::gimbal::SetRoiLocationResponse>*
        PrepareAsyncSetRoiLocationRaw(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::SetRoiLocationRequest& request,
            ::grpc::CompletionQueue* cq) override;
        ::grpc::ClientAsyncResponseReader<::mavsdk::rpc::gimbal::TakeControlResponse>*
        AsyncTakeControlRaw(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::TakeControlRequest& request,
            ::grpc::CompletionQueue* cq) override;
        ::grpc::ClientAsyncResponseReader<::mavsdk::rpc::gimbal::TakeControlResponse>*
        PrepareAsyncTakeControlRaw(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::TakeControlRequest& request,
            ::grpc::CompletionQueue* cq) override;
        ::grpc::ClientAsyncResponseReader<::mavsdk::rpc::gimbal::ReleaseControlResponse>*
        AsyncReleaseControlRaw(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::ReleaseControlRequest& request,
            ::grpc::CompletionQueue* cq) override;
        ::grpc::ClientAsyncResponseReader<::mavsdk::rpc::gimbal::ReleaseControlResponse>*
        PrepareAsyncReleaseControlRaw(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::ReleaseControlRequest& request,
            ::grpc::CompletionQueue* cq) override;
        ::grpc::ClientReader<::mavsdk::rpc::gimbal::ControlResponse>* SubscribeControlRaw(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::SubscribeControlRequest& request) override;
        ::grpc::ClientAsyncReader<::mavsdk::rpc::gimbal::ControlResponse>* AsyncSubscribeControlRaw(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::SubscribeControlRequest& request,
            ::grpc::CompletionQueue* cq,
            void* tag) override;
        ::grpc::ClientAsyncReader<::mavsdk::rpc::gimbal::ControlResponse>*
        PrepareAsyncSubscribeControlRaw(
            ::grpc::ClientContext* context,
            const ::mavsdk::rpc::gimbal::SubscribeControlRequest& request,
            ::grpc::CompletionQueue* cq) override;
        const ::grpc::internal::RpcMethod rpcmethod_SetPitchAndYaw_;
        const ::grpc::internal::RpcMethod rpcmethod_SetPitchRateAndYawRate_;
        const ::grpc::internal::RpcMethod rpcmethod_SetMode_;
        const ::grpc::internal::RpcMethod rpcmethod_SetRoiLocation_;
        const ::grpc::internal::RpcMethod rpcmethod_TakeControl_;
        const ::grpc::internal::RpcMethod rpcmethod_ReleaseControl_;
        const ::grpc::internal::RpcMethod rpcmethod_SubscribeControl_;
    };
    static std::unique_ptr<Stub> NewStub(
        const std::shared_ptr<::grpc::ChannelInterface>& channel,
        const ::grpc::StubOptions& options = ::grpc::StubOptions());

    class Service : public ::grpc::Service {
    public:
        Service();
        virtual ~Service();
        //
        //
        // Set gimbal pitch and yaw angles.
        //
        // This sets the desired pitch and yaw angles of a gimbal.
        // Will return when the command is accepted, however, it might
        // take the gimbal longer to actually be set to the new angles.
        virtual ::grpc::Status SetPitchAndYaw(
            ::grpc::ServerContext* context,
            const ::mavsdk::rpc::gimbal::SetPitchAndYawRequest* request,
            ::mavsdk::rpc::gimbal::SetPitchAndYawResponse* response);
        //
        //
        // Set gimbal angular rates around pitch and yaw axes.
        //
        // This sets the desired angular rates around pitch and yaw axes of a gimbal.
        // Will return when the command is accepted, however, it might
        // take the gimbal longer to actually reach the angular rate.
        virtual ::grpc::Status SetPitchRateAndYawRate(
            ::grpc::ServerContext* context,
            const ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateRequest* request,
            ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateResponse* response);
        //
        // Set gimbal mode.
        //
        // This sets the desired yaw mode of a gimbal.
        // Will return when the command is accepted. However, it might
        // take the gimbal longer to actually be set to the new angles.
        virtual ::grpc::Status SetMode(
            ::grpc::ServerContext* context,
            const ::mavsdk::rpc::gimbal::SetModeRequest* request,
            ::mavsdk::rpc::gimbal::SetModeResponse* response);
        //
        // Set gimbal region of interest (ROI).
        //
        // This sets a region of interest that the gimbal will point to.
        // The gimbal will continue to point to the specified region until it
        // receives a new command.
        // The function will return when the command is accepted, however, it might
        // take the gimbal longer to actually rotate to the ROI.
        virtual ::grpc::Status SetRoiLocation(
            ::grpc::ServerContext* context,
            const ::mavsdk::rpc::gimbal::SetRoiLocationRequest* request,
            ::mavsdk::rpc::gimbal::SetRoiLocationResponse* response);
        //
        // Take control.
        //
        // There can be only two components in control of a gimbal at any given time.
        // One with "primary" control, and one with "secondary" control. The way the
        // secondary control is implemented is not specified and hence depends on the
        // vehicle.
        //
        // Components are expected to be cooperative, which means that they can
        // override each other and should therefore do it carefully.
        virtual ::grpc::Status TakeControl(
            ::grpc::ServerContext* context,
            const ::mavsdk::rpc::gimbal::TakeControlRequest* request,
            ::mavsdk::rpc::gimbal::TakeControlResponse* response);
        //
        // Release control.
        //
        // Release control, such that other components can control the gimbal.
        virtual ::grpc::Status ReleaseControl(
            ::grpc::ServerContext* context,
            const ::mavsdk::rpc::gimbal::ReleaseControlRequest* request,
            ::mavsdk::rpc::gimbal::ReleaseControlResponse* response);
        //
        // Subscribe to control status updates.
        //
        // This allows a component to know if it has primary, secondary or
        // no control over the gimbal. Also, it gives the system and component ids
        // of the other components in control (if any).
        virtual ::grpc::Status SubscribeControl(
            ::grpc::ServerContext* context,
            const ::mavsdk::rpc::gimbal::SubscribeControlRequest* request,
            ::grpc::ServerWriter<::mavsdk::rpc::gimbal::ControlResponse>* writer);
    };
    template<class BaseClass> class WithAsyncMethod_SetPitchAndYaw : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        WithAsyncMethod_SetPitchAndYaw() { ::grpc::Service::MarkMethodAsync(0); }
        ~WithAsyncMethod_SetPitchAndYaw() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status SetPitchAndYaw(
            ::grpc::ServerContext* /*context*/,
            const ::mavsdk::rpc::gimbal::SetPitchAndYawRequest* /*request*/,
            ::mavsdk::rpc::gimbal::SetPitchAndYawResponse* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestSetPitchAndYaw(
            ::grpc::ServerContext* context,
            ::mavsdk::rpc::gimbal::SetPitchAndYawRequest* request,
            ::grpc::ServerAsyncResponseWriter<::mavsdk::rpc::gimbal::SetPitchAndYawResponse>*
                response,
            ::grpc::CompletionQueue* new_call_cq,
            ::grpc::ServerCompletionQueue* notification_cq,
            void* tag)
        {
            ::grpc::Service::RequestAsyncUnary(
                0, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template<class BaseClass> class WithAsyncMethod_SetPitchRateAndYawRate : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        WithAsyncMethod_SetPitchRateAndYawRate() { ::grpc::Service::MarkMethodAsync(1); }
        ~WithAsyncMethod_SetPitchRateAndYawRate() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status SetPitchRateAndYawRate(
            ::grpc::ServerContext* /*context*/,
            const ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateRequest* /*request*/,
            ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateResponse* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestSetPitchRateAndYawRate(
            ::grpc::ServerContext* context,
            ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateRequest* request,
            ::grpc::ServerAsyncResponseWriter<
                ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateResponse>* response,
            ::grpc::CompletionQueue* new_call_cq,
            ::grpc::ServerCompletionQueue* notification_cq,
            void* tag)
        {
            ::grpc::Service::RequestAsyncUnary(
                1, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template<class BaseClass> class WithAsyncMethod_SetMode : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        WithAsyncMethod_SetMode() { ::grpc::Service::MarkMethodAsync(2); }
        ~WithAsyncMethod_SetMode() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status SetMode(
            ::grpc::ServerContext* /*context*/,
            const ::mavsdk::rpc::gimbal::SetModeRequest* /*request*/,
            ::mavsdk::rpc::gimbal::SetModeResponse* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestSetMode(
            ::grpc::ServerContext* context,
            ::mavsdk::rpc::gimbal::SetModeRequest* request,
            ::grpc::ServerAsyncResponseWriter<::mavsdk::rpc::gimbal::SetModeResponse>* response,
            ::grpc::CompletionQueue* new_call_cq,
            ::grpc::ServerCompletionQueue* notification_cq,
            void* tag)
        {
            ::grpc::Service::RequestAsyncUnary(
                2, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template<class BaseClass> class WithAsyncMethod_SetRoiLocation : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        WithAsyncMethod_SetRoiLocation() { ::grpc::Service::MarkMethodAsync(3); }
        ~WithAsyncMethod_SetRoiLocation() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status SetRoiLocation(
            ::grpc::ServerContext* /*context*/,
            const ::mavsdk::rpc::gimbal::SetRoiLocationRequest* /*request*/,
            ::mavsdk::rpc::gimbal::SetRoiLocationResponse* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestSetRoiLocation(
            ::grpc::ServerContext* context,
            ::mavsdk::rpc::gimbal::SetRoiLocationRequest* request,
            ::grpc::ServerAsyncResponseWriter<::mavsdk::rpc::gimbal::SetRoiLocationResponse>*
                response,
            ::grpc::CompletionQueue* new_call_cq,
            ::grpc::ServerCompletionQueue* notification_cq,
            void* tag)
        {
            ::grpc::Service::RequestAsyncUnary(
                3, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template<class BaseClass> class WithAsyncMethod_TakeControl : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        WithAsyncMethod_TakeControl() { ::grpc::Service::MarkMethodAsync(4); }
        ~WithAsyncMethod_TakeControl() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status TakeControl(
            ::grpc::ServerContext* /*context*/,
            const ::mavsdk::rpc::gimbal::TakeControlRequest* /*request*/,
            ::mavsdk::rpc::gimbal::TakeControlResponse* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestTakeControl(
            ::grpc::ServerContext* context,
            ::mavsdk::rpc::gimbal::TakeControlRequest* request,
            ::grpc::ServerAsyncResponseWriter<::mavsdk::rpc::gimbal::TakeControlResponse>* response,
            ::grpc::CompletionQueue* new_call_cq,
            ::grpc::ServerCompletionQueue* notification_cq,
            void* tag)
        {
            ::grpc::Service::RequestAsyncUnary(
                4, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template<class BaseClass> class WithAsyncMethod_ReleaseControl : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        WithAsyncMethod_ReleaseControl() { ::grpc::Service::MarkMethodAsync(5); }
        ~WithAsyncMethod_ReleaseControl() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status ReleaseControl(
            ::grpc::ServerContext* /*context*/,
            const ::mavsdk::rpc::gimbal::ReleaseControlRequest* /*request*/,
            ::mavsdk::rpc::gimbal::ReleaseControlResponse* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestReleaseControl(
            ::grpc::ServerContext* context,
            ::mavsdk::rpc::gimbal::ReleaseControlRequest* request,
            ::grpc::ServerAsyncResponseWriter<::mavsdk::rpc::gimbal::ReleaseControlResponse>*
                response,
            ::grpc::CompletionQueue* new_call_cq,
            ::grpc::ServerCompletionQueue* notification_cq,
            void* tag)
        {
            ::grpc::Service::RequestAsyncUnary(
                5, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template<class BaseClass> class WithAsyncMethod_SubscribeControl : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        WithAsyncMethod_SubscribeControl() { ::grpc::Service::MarkMethodAsync(6); }
        ~WithAsyncMethod_SubscribeControl() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status SubscribeControl(
            ::grpc::ServerContext* /*context*/,
            const ::mavsdk::rpc::gimbal::SubscribeControlRequest* /*request*/,
            ::grpc::ServerWriter<::mavsdk::rpc::gimbal::ControlResponse>* /*writer*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestSubscribeControl(
            ::grpc::ServerContext* context,
            ::mavsdk::rpc::gimbal::SubscribeControlRequest* request,
            ::grpc::ServerAsyncWriter<::mavsdk::rpc::gimbal::ControlResponse>* writer,
            ::grpc::CompletionQueue* new_call_cq,
            ::grpc::ServerCompletionQueue* notification_cq,
            void* tag)
        {
            ::grpc::Service::RequestAsyncServerStreaming(
                6, context, request, writer, new_call_cq, notification_cq, tag);
        }
    };
    typedef WithAsyncMethod_SetPitchAndYaw<WithAsyncMethod_SetPitchRateAndYawRate<
        WithAsyncMethod_SetMode<WithAsyncMethod_SetRoiLocation<WithAsyncMethod_TakeControl<
            WithAsyncMethod_ReleaseControl<WithAsyncMethod_SubscribeControl<Service>>>>>>>
        AsyncService;
    template<class BaseClass>
    class ExperimentalWithCallbackMethod_SetPitchAndYaw : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        ExperimentalWithCallbackMethod_SetPitchAndYaw()
        {
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
#else
            ::grpc::Service::experimental().
#endif
                MarkMethodCallback(
                    0,
                    new ::grpc_impl::internal::CallbackUnaryHandler<
                        ::mavsdk::rpc::gimbal::SetPitchAndYawRequest,
                        ::mavsdk::rpc::gimbal::SetPitchAndYawResponse>(
                        [this](
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                            ::grpc::CallbackServerContext*
#else
                            ::grpc::experimental::CallbackServerContext*
#endif
                                context,
                            const ::mavsdk::rpc::gimbal::SetPitchAndYawRequest* request,
                            ::mavsdk::rpc::gimbal::SetPitchAndYawResponse* response) {
                            return this->SetPitchAndYaw(context, request, response);
                        }));
        }
        void SetMessageAllocatorFor_SetPitchAndYaw(
            ::grpc::experimental::MessageAllocator<
                ::mavsdk::rpc::gimbal::SetPitchAndYawRequest,
                ::mavsdk::rpc::gimbal::SetPitchAndYawResponse>* allocator)
        {
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
#else
            ::grpc::internal::MethodHandler* const handler =
                ::grpc::Service::experimental().GetHandler(0);
#endif
            static_cast<::grpc_impl::internal::CallbackUnaryHandler<
                ::mavsdk::rpc::gimbal::SetPitchAndYawRequest,
                ::mavsdk::rpc::gimbal::SetPitchAndYawResponse>*>(handler)
                ->SetMessageAllocator(allocator);
        }
        ~ExperimentalWithCallbackMethod_SetPitchAndYaw() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status SetPitchAndYaw(
            ::grpc::ServerContext* /*context*/,
            const ::mavsdk::rpc::gimbal::SetPitchAndYawRequest* /*request*/,
            ::mavsdk::rpc::gimbal::SetPitchAndYawResponse* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor* SetPitchAndYaw(
            ::grpc::CallbackServerContext* /*context*/,
            const ::mavsdk::rpc::gimbal::SetPitchAndYawRequest* /*request*/,
            ::mavsdk::rpc::gimbal::SetPitchAndYawResponse* /*response*/)
#else
        virtual ::grpc::experimental::ServerUnaryReactor* SetPitchAndYaw(
            ::grpc::experimental::CallbackServerContext* /*context*/,
            const ::mavsdk::rpc::gimbal::SetPitchAndYawRequest* /*request*/,
            ::mavsdk::rpc::gimbal::SetPitchAndYawResponse* /*response*/)
#endif
        {
            return nullptr;
        }
    };
    template<class BaseClass>
    class ExperimentalWithCallbackMethod_SetPitchRateAndYawRate : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        ExperimentalWithCallbackMethod_SetPitchRateAndYawRate()
        {
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
#else
            ::grpc::Service::experimental().
#endif
                MarkMethodCallback(
                    1,
                    new ::grpc_impl::internal::CallbackUnaryHandler<
                        ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateRequest,
                        ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateResponse>(
                        [this](
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                            ::grpc::CallbackServerContext*
#else
                            ::grpc::experimental::CallbackServerContext*
#endif
                                context,
                            const ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateRequest* request,
                            ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateResponse* response) {
                            return this->SetPitchRateAndYawRate(context, request, response);
                        }));
        }
        void SetMessageAllocatorFor_SetPitchRateAndYawRate(
            ::grpc::experimental::MessageAllocator<
                ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateRequest,
                ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateResponse>* allocator)
        {
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
#else
            ::grpc::internal::MethodHandler* const handler =
                ::grpc::Service::experimental().GetHandler(1);
#endif
            static_cast<::grpc_impl::internal::CallbackUnaryHandler<
                ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateRequest,
                ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateResponse>*>(handler)
                ->SetMessageAllocator(allocator);
        }
        ~ExperimentalWithCallbackMethod_SetPitchRateAndYawRate() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status SetPitchRateAndYawRate(
            ::grpc::ServerContext* /*context*/,
            const ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateRequest* /*request*/,
            ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateResponse* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor* SetPitchRateAndYawRate(
            ::grpc::CallbackServerContext* /*context*/,
            const ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateRequest* /*request*/,
            ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateResponse* /*response*/)
#else
        virtual ::grpc::experimental::ServerUnaryReactor* SetPitchRateAndYawRate(
            ::grpc::experimental::CallbackServerContext* /*context*/,
            const ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateRequest* /*request*/,
            ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateResponse* /*response*/)
#endif
        {
            return nullptr;
        }
    };
    template<class BaseClass> class ExperimentalWithCallbackMethod_SetMode : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        ExperimentalWithCallbackMethod_SetMode()
        {
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
#else
            ::grpc::Service::experimental().
#endif
                MarkMethodCallback(
                    2,
                    new ::grpc_impl::internal::CallbackUnaryHandler<
                        ::mavsdk::rpc::gimbal::SetModeRequest,
                        ::mavsdk::rpc::gimbal::SetModeResponse>(
                        [this](
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                            ::grpc::CallbackServerContext*
#else
                            ::grpc::experimental::CallbackServerContext*
#endif
                                context,
                            const ::mavsdk::rpc::gimbal::SetModeRequest* request,
                            ::mavsdk::rpc::gimbal::SetModeResponse* response) {
                            return this->SetMode(context, request, response);
                        }));
        }
        void SetMessageAllocatorFor_SetMode(::grpc::experimental::MessageAllocator<
                                            ::mavsdk::rpc::gimbal::SetModeRequest,
                                            ::mavsdk::rpc::gimbal::SetModeResponse>* allocator)
        {
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
#else
            ::grpc::internal::MethodHandler* const handler =
                ::grpc::Service::experimental().GetHandler(2);
#endif
            static_cast<::grpc_impl::internal::CallbackUnaryHandler<
                ::mavsdk::rpc::gimbal::SetModeRequest,
                ::mavsdk::rpc::gimbal::SetModeResponse>*>(handler)
                ->SetMessageAllocator(allocator);
        }
        ~ExperimentalWithCallbackMethod_SetMode() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status SetMode(
            ::grpc::ServerContext* /*context*/,
            const ::mavsdk::rpc::gimbal::SetModeRequest* /*request*/,
            ::mavsdk::rpc::gimbal::SetModeResponse* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor* SetMode(
            ::grpc::CallbackServerContext* /*context*/,
            const ::mavsdk::rpc::gimbal::SetModeRequest* /*request*/,
            ::mavsdk::rpc::gimbal::SetModeResponse* /*response*/)
#else
        virtual ::grpc::experimental::ServerUnaryReactor* SetMode(
            ::grpc::experimental::CallbackServerContext* /*context*/,
            const ::mavsdk::rpc::gimbal::SetModeRequest* /*request*/,
            ::mavsdk::rpc::gimbal::SetModeResponse* /*response*/)
#endif
        {
            return nullptr;
        }
    };
    template<class BaseClass>
    class ExperimentalWithCallbackMethod_SetRoiLocation : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        ExperimentalWithCallbackMethod_SetRoiLocation()
        {
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
#else
            ::grpc::Service::experimental().
#endif
                MarkMethodCallback(
                    3,
                    new ::grpc_impl::internal::CallbackUnaryHandler<
                        ::mavsdk::rpc::gimbal::SetRoiLocationRequest,
                        ::mavsdk::rpc::gimbal::SetRoiLocationResponse>(
                        [this](
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                            ::grpc::CallbackServerContext*
#else
                            ::grpc::experimental::CallbackServerContext*
#endif
                                context,
                            const ::mavsdk::rpc::gimbal::SetRoiLocationRequest* request,
                            ::mavsdk::rpc::gimbal::SetRoiLocationResponse* response) {
                            return this->SetRoiLocation(context, request, response);
                        }));
        }
        void SetMessageAllocatorFor_SetRoiLocation(
            ::grpc::experimental::MessageAllocator<
                ::mavsdk::rpc::gimbal::SetRoiLocationRequest,
                ::mavsdk::rpc::gimbal::SetRoiLocationResponse>* allocator)
        {
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
#else
            ::grpc::internal::MethodHandler* const handler =
                ::grpc::Service::experimental().GetHandler(3);
#endif
            static_cast<::grpc_impl::internal::CallbackUnaryHandler<
                ::mavsdk::rpc::gimbal::SetRoiLocationRequest,
                ::mavsdk::rpc::gimbal::SetRoiLocationResponse>*>(handler)
                ->SetMessageAllocator(allocator);
        }
        ~ExperimentalWithCallbackMethod_SetRoiLocation() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status SetRoiLocation(
            ::grpc::ServerContext* /*context*/,
            const ::mavsdk::rpc::gimbal::SetRoiLocationRequest* /*request*/,
            ::mavsdk::rpc::gimbal::SetRoiLocationResponse* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor* SetRoiLocation(
            ::grpc::CallbackServerContext* /*context*/,
            const ::mavsdk::rpc::gimbal::SetRoiLocationRequest* /*request*/,
            ::mavsdk::rpc::gimbal::SetRoiLocationResponse* /*response*/)
#else
        virtual ::grpc::experimental::ServerUnaryReactor* SetRoiLocation(
            ::grpc::experimental::CallbackServerContext* /*context*/,
            const ::mavsdk::rpc::gimbal::SetRoiLocationRequest* /*request*/,
            ::mavsdk::rpc::gimbal::SetRoiLocationResponse* /*response*/)
#endif
        {
            return nullptr;
        }
    };
    template<class BaseClass> class ExperimentalWithCallbackMethod_TakeControl : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        ExperimentalWithCallbackMethod_TakeControl()
        {
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
#else
            ::grpc::Service::experimental().
#endif
                MarkMethodCallback(
                    4,
                    new ::grpc_impl::internal::CallbackUnaryHandler<
                        ::mavsdk::rpc::gimbal::TakeControlRequest,
                        ::mavsdk::rpc::gimbal::TakeControlResponse>(
                        [this](
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                            ::grpc::CallbackServerContext*
#else
                            ::grpc::experimental::CallbackServerContext*
#endif
                                context,
                            const ::mavsdk::rpc::gimbal::TakeControlRequest* request,
                            ::mavsdk::rpc::gimbal::TakeControlResponse* response) {
                            return this->TakeControl(context, request, response);
                        }));
        }
        void
        SetMessageAllocatorFor_TakeControl(::grpc::experimental::MessageAllocator<
                                           ::mavsdk::rpc::gimbal::TakeControlRequest,
                                           ::mavsdk::rpc::gimbal::TakeControlResponse>* allocator)
        {
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
#else
            ::grpc::internal::MethodHandler* const handler =
                ::grpc::Service::experimental().GetHandler(4);
#endif
            static_cast<::grpc_impl::internal::CallbackUnaryHandler<
                ::mavsdk::rpc::gimbal::TakeControlRequest,
                ::mavsdk::rpc::gimbal::TakeControlResponse>*>(handler)
                ->SetMessageAllocator(allocator);
        }
        ~ExperimentalWithCallbackMethod_TakeControl() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status TakeControl(
            ::grpc::ServerContext* /*context*/,
            const ::mavsdk::rpc::gimbal::TakeControlRequest* /*request*/,
            ::mavsdk::rpc::gimbal::TakeControlResponse* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor* TakeControl(
            ::grpc::CallbackServerContext* /*context*/,
            const ::mavsdk::rpc::gimbal::TakeControlRequest* /*request*/,
            ::mavsdk::rpc::gimbal::TakeControlResponse* /*response*/)
#else
        virtual ::grpc::experimental::ServerUnaryReactor* TakeControl(
            ::grpc::experimental::CallbackServerContext* /*context*/,
            const ::mavsdk::rpc::gimbal::TakeControlRequest* /*request*/,
            ::mavsdk::rpc::gimbal::TakeControlResponse* /*response*/)
#endif
        {
            return nullptr;
        }
    };
    template<class BaseClass>
    class ExperimentalWithCallbackMethod_ReleaseControl : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        ExperimentalWithCallbackMethod_ReleaseControl()
        {
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
#else
            ::grpc::Service::experimental().
#endif
                MarkMethodCallback(
                    5,
                    new ::grpc_impl::internal::CallbackUnaryHandler<
                        ::mavsdk::rpc::gimbal::ReleaseControlRequest,
                        ::mavsdk::rpc::gimbal::ReleaseControlResponse>(
                        [this](
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                            ::grpc::CallbackServerContext*
#else
                            ::grpc::experimental::CallbackServerContext*
#endif
                                context,
                            const ::mavsdk::rpc::gimbal::ReleaseControlRequest* request,
                            ::mavsdk::rpc::gimbal::ReleaseControlResponse* response) {
                            return this->ReleaseControl(context, request, response);
                        }));
        }
        void SetMessageAllocatorFor_ReleaseControl(
            ::grpc::experimental::MessageAllocator<
                ::mavsdk::rpc::gimbal::ReleaseControlRequest,
                ::mavsdk::rpc::gimbal::ReleaseControlResponse>* allocator)
        {
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
#else
            ::grpc::internal::MethodHandler* const handler =
                ::grpc::Service::experimental().GetHandler(5);
#endif
            static_cast<::grpc_impl::internal::CallbackUnaryHandler<
                ::mavsdk::rpc::gimbal::ReleaseControlRequest,
                ::mavsdk::rpc::gimbal::ReleaseControlResponse>*>(handler)
                ->SetMessageAllocator(allocator);
        }
        ~ExperimentalWithCallbackMethod_ReleaseControl() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status ReleaseControl(
            ::grpc::ServerContext* /*context*/,
            const ::mavsdk::rpc::gimbal::ReleaseControlRequest* /*request*/,
            ::mavsdk::rpc::gimbal::ReleaseControlResponse* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor* ReleaseControl(
            ::grpc::CallbackServerContext* /*context*/,
            const ::mavsdk::rpc::gimbal::ReleaseControlRequest* /*request*/,
            ::mavsdk::rpc::gimbal::ReleaseControlResponse* /*response*/)
#else
        virtual ::grpc::experimental::ServerUnaryReactor* ReleaseControl(
            ::grpc::experimental::CallbackServerContext* /*context*/,
            const ::mavsdk::rpc::gimbal::ReleaseControlRequest* /*request*/,
            ::mavsdk::rpc::gimbal::ReleaseControlResponse* /*response*/)
#endif
        {
            return nullptr;
        }
    };
    template<class BaseClass>
    class ExperimentalWithCallbackMethod_SubscribeControl : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        ExperimentalWithCallbackMethod_SubscribeControl()
        {
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
#else
            ::grpc::Service::experimental().
#endif
                MarkMethodCallback(
                    6,
                    new ::grpc_impl::internal::CallbackServerStreamingHandler<
                        ::mavsdk::rpc::gimbal::SubscribeControlRequest,
                        ::mavsdk::rpc::gimbal::ControlResponse>(
                        [this](
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                            ::grpc::CallbackServerContext*
#else
                            ::grpc::experimental::CallbackServerContext*
#endif
                                context,
                            const ::mavsdk::rpc::gimbal::SubscribeControlRequest* request) {
                            return this->SubscribeControl(context, request);
                        }));
        }
        ~ExperimentalWithCallbackMethod_SubscribeControl() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status SubscribeControl(
            ::grpc::ServerContext* /*context*/,
            const ::mavsdk::rpc::gimbal::SubscribeControlRequest* /*request*/,
            ::grpc::ServerWriter<::mavsdk::rpc::gimbal::ControlResponse>* /*writer*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerWriteReactor<::mavsdk::rpc::gimbal::ControlResponse>*
        SubscribeControl(
            ::grpc::CallbackServerContext* /*context*/,
            const ::mavsdk::rpc::gimbal::SubscribeControlRequest* /*request*/)
#else
        virtual ::grpc::experimental::ServerWriteReactor<::mavsdk::rpc::gimbal::ControlResponse>*
        SubscribeControl(
            ::grpc::experimental::CallbackServerContext* /*context*/,
            const ::mavsdk::rpc::gimbal::SubscribeControlRequest* /*request*/)
#endif
        {
            return nullptr;
        }
    };
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef ExperimentalWithCallbackMethod_SetPitchAndYaw<
        ExperimentalWithCallbackMethod_SetPitchRateAndYawRate<
            ExperimentalWithCallbackMethod_SetMode<ExperimentalWithCallbackMethod_SetRoiLocation<
                ExperimentalWithCallbackMethod_TakeControl<
                    ExperimentalWithCallbackMethod_ReleaseControl<
                        ExperimentalWithCallbackMethod_SubscribeControl<Service>>>>>>>
        CallbackService;
#endif

    typedef ExperimentalWithCallbackMethod_SetPitchAndYaw<
        ExperimentalWithCallbackMethod_SetPitchRateAndYawRate<
            ExperimentalWithCallbackMethod_SetMode<ExperimentalWithCallbackMethod_SetRoiLocation<
                ExperimentalWithCallbackMethod_TakeControl<
                    ExperimentalWithCallbackMethod_ReleaseControl<
                        ExperimentalWithCallbackMethod_SubscribeControl<Service>>>>>>>
        ExperimentalCallbackService;
    template<class BaseClass> class WithGenericMethod_SetPitchAndYaw : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        WithGenericMethod_SetPitchAndYaw() { ::grpc::Service::MarkMethodGeneric(0); }
        ~WithGenericMethod_SetPitchAndYaw() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status SetPitchAndYaw(
            ::grpc::ServerContext* /*context*/,
            const ::mavsdk::rpc::gimbal::SetPitchAndYawRequest* /*request*/,
            ::mavsdk::rpc::gimbal::SetPitchAndYawResponse* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    };
    template<class BaseClass> class WithGenericMethod_SetPitchRateAndYawRate : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        WithGenericMethod_SetPitchRateAndYawRate() { ::grpc::Service::MarkMethodGeneric(1); }
        ~WithGenericMethod_SetPitchRateAndYawRate() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status SetPitchRateAndYawRate(
            ::grpc::ServerContext* /*context*/,
            const ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateRequest* /*request*/,
            ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateResponse* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    };
    template<class BaseClass> class WithGenericMethod_SetMode : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        WithGenericMethod_SetMode() { ::grpc::Service::MarkMethodGeneric(2); }
        ~WithGenericMethod_SetMode() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status SetMode(
            ::grpc::ServerContext* /*context*/,
            const ::mavsdk::rpc::gimbal::SetModeRequest* /*request*/,
            ::mavsdk::rpc::gimbal::SetModeResponse* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    };
    template<class BaseClass> class WithGenericMethod_SetRoiLocation : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        WithGenericMethod_SetRoiLocation() { ::grpc::Service::MarkMethodGeneric(3); }
        ~WithGenericMethod_SetRoiLocation() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status SetRoiLocation(
            ::grpc::ServerContext* /*context*/,
            const ::mavsdk::rpc::gimbal::SetRoiLocationRequest* /*request*/,
            ::mavsdk::rpc::gimbal::SetRoiLocationResponse* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    };
    template<class BaseClass> class WithGenericMethod_TakeControl : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        WithGenericMethod_TakeControl() { ::grpc::Service::MarkMethodGeneric(4); }
        ~WithGenericMethod_TakeControl() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status TakeControl(
            ::grpc::ServerContext* /*context*/,
            const ::mavsdk::rpc::gimbal::TakeControlRequest* /*request*/,
            ::mavsdk::rpc::gimbal::TakeControlResponse* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    };
    template<class BaseClass> class WithGenericMethod_ReleaseControl : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        WithGenericMethod_ReleaseControl() { ::grpc::Service::MarkMethodGeneric(5); }
        ~WithGenericMethod_ReleaseControl() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status ReleaseControl(
            ::grpc::ServerContext* /*context*/,
            const ::mavsdk::rpc::gimbal::ReleaseControlRequest* /*request*/,
            ::mavsdk::rpc::gimbal::ReleaseControlResponse* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    };
    template<class BaseClass> class WithGenericMethod_SubscribeControl : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        WithGenericMethod_SubscribeControl() { ::grpc::Service::MarkMethodGeneric(6); }
        ~WithGenericMethod_SubscribeControl() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status SubscribeControl(
            ::grpc::ServerContext* /*context*/,
            const ::mavsdk::rpc::gimbal::SubscribeControlRequest* /*request*/,
            ::grpc::ServerWriter<::mavsdk::rpc::gimbal::ControlResponse>* /*writer*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    };
    template<class BaseClass> class WithRawMethod_SetPitchAndYaw : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        WithRawMethod_SetPitchAndYaw() { ::grpc::Service::MarkMethodRaw(0); }
        ~WithRawMethod_SetPitchAndYaw() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status SetPitchAndYaw(
            ::grpc::ServerContext* /*context*/,
            const ::mavsdk::rpc::gimbal::SetPitchAndYawRequest* /*request*/,
            ::mavsdk::rpc::gimbal::SetPitchAndYawResponse* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestSetPitchAndYaw(
            ::grpc::ServerContext* context,
            ::grpc::ByteBuffer* request,
            ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer>* response,
            ::grpc::CompletionQueue* new_call_cq,
            ::grpc::ServerCompletionQueue* notification_cq,
            void* tag)
        {
            ::grpc::Service::RequestAsyncUnary(
                0, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template<class BaseClass> class WithRawMethod_SetPitchRateAndYawRate : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        WithRawMethod_SetPitchRateAndYawRate() { ::grpc::Service::MarkMethodRaw(1); }
        ~WithRawMethod_SetPitchRateAndYawRate() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status SetPitchRateAndYawRate(
            ::grpc::ServerContext* /*context*/,
            const ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateRequest* /*request*/,
            ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateResponse* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestSetPitchRateAndYawRate(
            ::grpc::ServerContext* context,
            ::grpc::ByteBuffer* request,
            ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer>* response,
            ::grpc::CompletionQueue* new_call_cq,
            ::grpc::ServerCompletionQueue* notification_cq,
            void* tag)
        {
            ::grpc::Service::RequestAsyncUnary(
                1, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template<class BaseClass> class WithRawMethod_SetMode : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        WithRawMethod_SetMode() { ::grpc::Service::MarkMethodRaw(2); }
        ~WithRawMethod_SetMode() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status SetMode(
            ::grpc::ServerContext* /*context*/,
            const ::mavsdk::rpc::gimbal::SetModeRequest* /*request*/,
            ::mavsdk::rpc::gimbal::SetModeResponse* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestSetMode(
            ::grpc::ServerContext* context,
            ::grpc::ByteBuffer* request,
            ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer>* response,
            ::grpc::CompletionQueue* new_call_cq,
            ::grpc::ServerCompletionQueue* notification_cq,
            void* tag)
        {
            ::grpc::Service::RequestAsyncUnary(
                2, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template<class BaseClass> class WithRawMethod_SetRoiLocation : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        WithRawMethod_SetRoiLocation() { ::grpc::Service::MarkMethodRaw(3); }
        ~WithRawMethod_SetRoiLocation() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status SetRoiLocation(
            ::grpc::ServerContext* /*context*/,
            const ::mavsdk::rpc::gimbal::SetRoiLocationRequest* /*request*/,
            ::mavsdk::rpc::gimbal::SetRoiLocationResponse* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestSetRoiLocation(
            ::grpc::ServerContext* context,
            ::grpc::ByteBuffer* request,
            ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer>* response,
            ::grpc::CompletionQueue* new_call_cq,
            ::grpc::ServerCompletionQueue* notification_cq,
            void* tag)
        {
            ::grpc::Service::RequestAsyncUnary(
                3, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template<class BaseClass> class WithRawMethod_TakeControl : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        WithRawMethod_TakeControl() { ::grpc::Service::MarkMethodRaw(4); }
        ~WithRawMethod_TakeControl() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status TakeControl(
            ::grpc::ServerContext* /*context*/,
            const ::mavsdk::rpc::gimbal::TakeControlRequest* /*request*/,
            ::mavsdk::rpc::gimbal::TakeControlResponse* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestTakeControl(
            ::grpc::ServerContext* context,
            ::grpc::ByteBuffer* request,
            ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer>* response,
            ::grpc::CompletionQueue* new_call_cq,
            ::grpc::ServerCompletionQueue* notification_cq,
            void* tag)
        {
            ::grpc::Service::RequestAsyncUnary(
                4, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template<class BaseClass> class WithRawMethod_ReleaseControl : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        WithRawMethod_ReleaseControl() { ::grpc::Service::MarkMethodRaw(5); }
        ~WithRawMethod_ReleaseControl() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status ReleaseControl(
            ::grpc::ServerContext* /*context*/,
            const ::mavsdk::rpc::gimbal::ReleaseControlRequest* /*request*/,
            ::mavsdk::rpc::gimbal::ReleaseControlResponse* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestReleaseControl(
            ::grpc::ServerContext* context,
            ::grpc::ByteBuffer* request,
            ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer>* response,
            ::grpc::CompletionQueue* new_call_cq,
            ::grpc::ServerCompletionQueue* notification_cq,
            void* tag)
        {
            ::grpc::Service::RequestAsyncUnary(
                5, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template<class BaseClass> class WithRawMethod_SubscribeControl : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        WithRawMethod_SubscribeControl() { ::grpc::Service::MarkMethodRaw(6); }
        ~WithRawMethod_SubscribeControl() override { BaseClassMustBeDerivedFromService(this); }
        // disable synchronous version of this method
        ::grpc::Status SubscribeControl(
            ::grpc::ServerContext* /*context*/,
            const ::mavsdk::rpc::gimbal::SubscribeControlRequest* /*request*/,
            ::grpc::ServerWriter<::mavsdk::rpc::gimbal::ControlResponse>* /*writer*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestSubscribeControl(
            ::grpc::ServerContext* context,
            ::grpc::ByteBuffer* request,
            ::grpc::ServerAsyncWriter<::grpc::ByteBuffer>* writer,
            ::grpc::CompletionQueue* new_call_cq,
            ::grpc::ServerCompletionQueue* notification_cq,
            void* tag)
        {
            ::grpc::Service::RequestAsyncServerStreaming(
                6, context, request, writer, new_call_cq, notification_cq, tag);
        }
    };
    template<class BaseClass>
    class ExperimentalWithRawCallbackMethod_SetPitchAndYaw : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        ExperimentalWithRawCallbackMethod_SetPitchAndYaw()
        {
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
#else
            ::grpc::Service::experimental().
#endif
                MarkMethodRawCallback(
                    0,
                    new ::grpc_impl::internal::
                        CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                            [this](
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                                ::grpc::CallbackServerContext*
#else
                                ::grpc::experimental::CallbackServerContext*
#endif
                                    context,
                                const ::grpc::ByteBuffer* request,
                                ::grpc::ByteBuffer* response) {
                                return this->SetPitchAndYaw(context, request, response);
                            }));
        }
        ~ExperimentalWithRawCallbackMethod_SetPitchAndYaw() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status SetPitchAndYaw(
            ::grpc::ServerContext* /*context*/,
            const ::mavsdk::rpc::gimbal::SetPitchAndYawRequest* /*request*/,
            ::mavsdk::rpc::gimbal::SetPitchAndYawResponse* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor* SetPitchAndYaw(
            ::grpc::CallbackServerContext* /*context*/,
            const ::grpc::ByteBuffer* /*request*/,
            ::grpc::ByteBuffer* /*response*/)
#else
        virtual ::grpc::experimental::ServerUnaryReactor* SetPitchAndYaw(
            ::grpc::experimental::CallbackServerContext* /*context*/,
            const ::grpc::ByteBuffer* /*request*/,
            ::grpc::ByteBuffer* /*response*/)
#endif
        {
            return nullptr;
        }
    };
    template<class BaseClass>
    class ExperimentalWithRawCallbackMethod_SetPitchRateAndYawRate : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        ExperimentalWithRawCallbackMethod_SetPitchRateAndYawRate()
        {
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
#else
            ::grpc::Service::experimental().
#endif
                MarkMethodRawCallback(
                    1,
                    new ::grpc_impl::internal::
                        CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                            [this](
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                                ::grpc::CallbackServerContext*
#else
                                ::grpc::experimental::CallbackServerContext*
#endif
                                    context,
                                const ::grpc::ByteBuffer* request,
                                ::grpc::ByteBuffer* response) {
                                return this->SetPitchRateAndYawRate(context, request, response);
                            }));
        }
        ~ExperimentalWithRawCallbackMethod_SetPitchRateAndYawRate() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status SetPitchRateAndYawRate(
            ::grpc::ServerContext* /*context*/,
            const ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateRequest* /*request*/,
            ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateResponse* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor* SetPitchRateAndYawRate(
            ::grpc::CallbackServerContext* /*context*/,
            const ::grpc::ByteBuffer* /*request*/,
            ::grpc::ByteBuffer* /*response*/)
#else
        virtual ::grpc::experimental::ServerUnaryReactor* SetPitchRateAndYawRate(
            ::grpc::experimental::CallbackServerContext* /*context*/,
            const ::grpc::ByteBuffer* /*request*/,
            ::grpc::ByteBuffer* /*response*/)
#endif
        {
            return nullptr;
        }
    };
    template<class BaseClass> class ExperimentalWithRawCallbackMethod_SetMode : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        ExperimentalWithRawCallbackMethod_SetMode()
        {
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
#else
            ::grpc::Service::experimental().
#endif
                MarkMethodRawCallback(
                    2,
                    new ::grpc_impl::internal::
                        CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                            [this](
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                                ::grpc::CallbackServerContext*
#else
                                ::grpc::experimental::CallbackServerContext*
#endif
                                    context,
                                const ::grpc::ByteBuffer* request,
                                ::grpc::ByteBuffer* response) {
                                return this->SetMode(context, request, response);
                            }));
        }
        ~ExperimentalWithRawCallbackMethod_SetMode() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status SetMode(
            ::grpc::ServerContext* /*context*/,
            const ::mavsdk::rpc::gimbal::SetModeRequest* /*request*/,
            ::mavsdk::rpc::gimbal::SetModeResponse* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor* SetMode(
            ::grpc::CallbackServerContext* /*context*/,
            const ::grpc::ByteBuffer* /*request*/,
            ::grpc::ByteBuffer* /*response*/)
#else
        virtual ::grpc::experimental::ServerUnaryReactor* SetMode(
            ::grpc::experimental::CallbackServerContext* /*context*/,
            const ::grpc::ByteBuffer* /*request*/,
            ::grpc::ByteBuffer* /*response*/)
#endif
        {
            return nullptr;
        }
    };
    template<class BaseClass>
    class ExperimentalWithRawCallbackMethod_SetRoiLocation : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        ExperimentalWithRawCallbackMethod_SetRoiLocation()
        {
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
#else
            ::grpc::Service::experimental().
#endif
                MarkMethodRawCallback(
                    3,
                    new ::grpc_impl::internal::
                        CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                            [this](
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                                ::grpc::CallbackServerContext*
#else
                                ::grpc::experimental::CallbackServerContext*
#endif
                                    context,
                                const ::grpc::ByteBuffer* request,
                                ::grpc::ByteBuffer* response) {
                                return this->SetRoiLocation(context, request, response);
                            }));
        }
        ~ExperimentalWithRawCallbackMethod_SetRoiLocation() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status SetRoiLocation(
            ::grpc::ServerContext* /*context*/,
            const ::mavsdk::rpc::gimbal::SetRoiLocationRequest* /*request*/,
            ::mavsdk::rpc::gimbal::SetRoiLocationResponse* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor* SetRoiLocation(
            ::grpc::CallbackServerContext* /*context*/,
            const ::grpc::ByteBuffer* /*request*/,
            ::grpc::ByteBuffer* /*response*/)
#else
        virtual ::grpc::experimental::ServerUnaryReactor* SetRoiLocation(
            ::grpc::experimental::CallbackServerContext* /*context*/,
            const ::grpc::ByteBuffer* /*request*/,
            ::grpc::ByteBuffer* /*response*/)
#endif
        {
            return nullptr;
        }
    };
    template<class BaseClass>
    class ExperimentalWithRawCallbackMethod_TakeControl : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        ExperimentalWithRawCallbackMethod_TakeControl()
        {
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
#else
            ::grpc::Service::experimental().
#endif
                MarkMethodRawCallback(
                    4,
                    new ::grpc_impl::internal::
                        CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                            [this](
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                                ::grpc::CallbackServerContext*
#else
                                ::grpc::experimental::CallbackServerContext*
#endif
                                    context,
                                const ::grpc::ByteBuffer* request,
                                ::grpc::ByteBuffer* response) {
                                return this->TakeControl(context, request, response);
                            }));
        }
        ~ExperimentalWithRawCallbackMethod_TakeControl() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status TakeControl(
            ::grpc::ServerContext* /*context*/,
            const ::mavsdk::rpc::gimbal::TakeControlRequest* /*request*/,
            ::mavsdk::rpc::gimbal::TakeControlResponse* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor* TakeControl(
            ::grpc::CallbackServerContext* /*context*/,
            const ::grpc::ByteBuffer* /*request*/,
            ::grpc::ByteBuffer* /*response*/)
#else
        virtual ::grpc::experimental::ServerUnaryReactor* TakeControl(
            ::grpc::experimental::CallbackServerContext* /*context*/,
            const ::grpc::ByteBuffer* /*request*/,
            ::grpc::ByteBuffer* /*response*/)
#endif
        {
            return nullptr;
        }
    };
    template<class BaseClass>
    class ExperimentalWithRawCallbackMethod_ReleaseControl : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        ExperimentalWithRawCallbackMethod_ReleaseControl()
        {
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
#else
            ::grpc::Service::experimental().
#endif
                MarkMethodRawCallback(
                    5,
                    new ::grpc_impl::internal::
                        CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                            [this](
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                                ::grpc::CallbackServerContext*
#else
                                ::grpc::experimental::CallbackServerContext*
#endif
                                    context,
                                const ::grpc::ByteBuffer* request,
                                ::grpc::ByteBuffer* response) {
                                return this->ReleaseControl(context, request, response);
                            }));
        }
        ~ExperimentalWithRawCallbackMethod_ReleaseControl() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status ReleaseControl(
            ::grpc::ServerContext* /*context*/,
            const ::mavsdk::rpc::gimbal::ReleaseControlRequest* /*request*/,
            ::mavsdk::rpc::gimbal::ReleaseControlResponse* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor* ReleaseControl(
            ::grpc::CallbackServerContext* /*context*/,
            const ::grpc::ByteBuffer* /*request*/,
            ::grpc::ByteBuffer* /*response*/)
#else
        virtual ::grpc::experimental::ServerUnaryReactor* ReleaseControl(
            ::grpc::experimental::CallbackServerContext* /*context*/,
            const ::grpc::ByteBuffer* /*request*/,
            ::grpc::ByteBuffer* /*response*/)
#endif
        {
            return nullptr;
        }
    };
    template<class BaseClass>
    class ExperimentalWithRawCallbackMethod_SubscribeControl : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        ExperimentalWithRawCallbackMethod_SubscribeControl()
        {
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
#else
            ::grpc::Service::experimental().
#endif
                MarkMethodRawCallback(
                    6,
                    new ::grpc_impl::internal::
                        CallbackServerStreamingHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                            [this](
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                                ::grpc::CallbackServerContext*
#else
                                ::grpc::experimental::CallbackServerContext*
#endif
                                    context,
                                const ::grpc::ByteBuffer* request) {
                                return this->SubscribeControl(context, request);
                            }));
        }
        ~ExperimentalWithRawCallbackMethod_SubscribeControl() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status SubscribeControl(
            ::grpc::ServerContext* /*context*/,
            const ::mavsdk::rpc::gimbal::SubscribeControlRequest* /*request*/,
            ::grpc::ServerWriter<::mavsdk::rpc::gimbal::ControlResponse>* /*writer*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
#ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerWriteReactor<::grpc::ByteBuffer>* SubscribeControl(
            ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
#else
        virtual ::grpc::experimental::ServerWriteReactor<::grpc::ByteBuffer>* SubscribeControl(
            ::grpc::experimental::CallbackServerContext* /*context*/,
            const ::grpc::ByteBuffer* /*request*/)
#endif
        {
            return nullptr;
        }
    };
    template<class BaseClass> class WithStreamedUnaryMethod_SetPitchAndYaw : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        WithStreamedUnaryMethod_SetPitchAndYaw()
        {
            ::grpc::Service::MarkMethodStreamed(
                0,
                new ::grpc::internal::StreamedUnaryHandler<
                    ::mavsdk::rpc::gimbal::SetPitchAndYawRequest,
                    ::mavsdk::rpc::gimbal::SetPitchAndYawResponse>(
                    [this](
                        ::grpc_impl::ServerContext* context,
                        ::grpc_impl::ServerUnaryStreamer<
                            ::mavsdk::rpc::gimbal::SetPitchAndYawRequest,
                            ::mavsdk::rpc::gimbal::SetPitchAndYawResponse>* streamer) {
                        return this->StreamedSetPitchAndYaw(context, streamer);
                    }));
        }
        ~WithStreamedUnaryMethod_SetPitchAndYaw() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable regular version of this method
        ::grpc::Status SetPitchAndYaw(
            ::grpc::ServerContext* /*context*/,
            const ::mavsdk::rpc::gimbal::SetPitchAndYawRequest* /*request*/,
            ::mavsdk::rpc::gimbal::SetPitchAndYawResponse* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        // replace default version of method with streamed unary
        virtual ::grpc::Status StreamedSetPitchAndYaw(
            ::grpc::ServerContext* context,
            ::grpc::ServerUnaryStreamer<
                ::mavsdk::rpc::gimbal::SetPitchAndYawRequest,
                ::mavsdk::rpc::gimbal::SetPitchAndYawResponse>* server_unary_streamer) = 0;
    };
    template<class BaseClass>
    class WithStreamedUnaryMethod_SetPitchRateAndYawRate : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        WithStreamedUnaryMethod_SetPitchRateAndYawRate()
        {
            ::grpc::Service::MarkMethodStreamed(
                1,
                new ::grpc::internal::StreamedUnaryHandler<
                    ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateRequest,
                    ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateResponse>(
                    [this](
                        ::grpc_impl::ServerContext* context,
                        ::grpc_impl::ServerUnaryStreamer<
                            ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateRequest,
                            ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateResponse>* streamer) {
                        return this->StreamedSetPitchRateAndYawRate(context, streamer);
                    }));
        }
        ~WithStreamedUnaryMethod_SetPitchRateAndYawRate() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable regular version of this method
        ::grpc::Status SetPitchRateAndYawRate(
            ::grpc::ServerContext* /*context*/,
            const ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateRequest* /*request*/,
            ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateResponse* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        // replace default version of method with streamed unary
        virtual ::grpc::Status StreamedSetPitchRateAndYawRate(
            ::grpc::ServerContext* context,
            ::grpc::ServerUnaryStreamer<
                ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateRequest,
                ::mavsdk::rpc::gimbal::SetPitchRateAndYawRateResponse>* server_unary_streamer) = 0;
    };
    template<class BaseClass> class WithStreamedUnaryMethod_SetMode : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        WithStreamedUnaryMethod_SetMode()
        {
            ::grpc::Service::MarkMethodStreamed(
                2,
                new ::grpc::internal::StreamedUnaryHandler<
                    ::mavsdk::rpc::gimbal::SetModeRequest,
                    ::mavsdk::rpc::gimbal::SetModeResponse>(
                    [this](
                        ::grpc_impl::ServerContext* context,
                        ::grpc_impl::ServerUnaryStreamer<
                            ::mavsdk::rpc::gimbal::SetModeRequest,
                            ::mavsdk::rpc::gimbal::SetModeResponse>* streamer) {
                        return this->StreamedSetMode(context, streamer);
                    }));
        }
        ~WithStreamedUnaryMethod_SetMode() override { BaseClassMustBeDerivedFromService(this); }
        // disable regular version of this method
        ::grpc::Status SetMode(
            ::grpc::ServerContext* /*context*/,
            const ::mavsdk::rpc::gimbal::SetModeRequest* /*request*/,
            ::mavsdk::rpc::gimbal::SetModeResponse* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        // replace default version of method with streamed unary
        virtual ::grpc::Status StreamedSetMode(
            ::grpc::ServerContext* context,
            ::grpc::ServerUnaryStreamer<
                ::mavsdk::rpc::gimbal::SetModeRequest,
                ::mavsdk::rpc::gimbal::SetModeResponse>* server_unary_streamer) = 0;
    };
    template<class BaseClass> class WithStreamedUnaryMethod_SetRoiLocation : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        WithStreamedUnaryMethod_SetRoiLocation()
        {
            ::grpc::Service::MarkMethodStreamed(
                3,
                new ::grpc::internal::StreamedUnaryHandler<
                    ::mavsdk::rpc::gimbal::SetRoiLocationRequest,
                    ::mavsdk::rpc::gimbal::SetRoiLocationResponse>(
                    [this](
                        ::grpc_impl::ServerContext* context,
                        ::grpc_impl::ServerUnaryStreamer<
                            ::mavsdk::rpc::gimbal::SetRoiLocationRequest,
                            ::mavsdk::rpc::gimbal::SetRoiLocationResponse>* streamer) {
                        return this->StreamedSetRoiLocation(context, streamer);
                    }));
        }
        ~WithStreamedUnaryMethod_SetRoiLocation() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable regular version of this method
        ::grpc::Status SetRoiLocation(
            ::grpc::ServerContext* /*context*/,
            const ::mavsdk::rpc::gimbal::SetRoiLocationRequest* /*request*/,
            ::mavsdk::rpc::gimbal::SetRoiLocationResponse* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        // replace default version of method with streamed unary
        virtual ::grpc::Status StreamedSetRoiLocation(
            ::grpc::ServerContext* context,
            ::grpc::ServerUnaryStreamer<
                ::mavsdk::rpc::gimbal::SetRoiLocationRequest,
                ::mavsdk::rpc::gimbal::SetRoiLocationResponse>* server_unary_streamer) = 0;
    };
    template<class BaseClass> class WithStreamedUnaryMethod_TakeControl : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        WithStreamedUnaryMethod_TakeControl()
        {
            ::grpc::Service::MarkMethodStreamed(
                4,
                new ::grpc::internal::StreamedUnaryHandler<
                    ::mavsdk::rpc::gimbal::TakeControlRequest,
                    ::mavsdk::rpc::gimbal::TakeControlResponse>(
                    [this](
                        ::grpc_impl::ServerContext* context,
                        ::grpc_impl::ServerUnaryStreamer<
                            ::mavsdk::rpc::gimbal::TakeControlRequest,
                            ::mavsdk::rpc::gimbal::TakeControlResponse>* streamer) {
                        return this->StreamedTakeControl(context, streamer);
                    }));
        }
        ~WithStreamedUnaryMethod_TakeControl() override { BaseClassMustBeDerivedFromService(this); }
        // disable regular version of this method
        ::grpc::Status TakeControl(
            ::grpc::ServerContext* /*context*/,
            const ::mavsdk::rpc::gimbal::TakeControlRequest* /*request*/,
            ::mavsdk::rpc::gimbal::TakeControlResponse* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        // replace default version of method with streamed unary
        virtual ::grpc::Status StreamedTakeControl(
            ::grpc::ServerContext* context,
            ::grpc::ServerUnaryStreamer<
                ::mavsdk::rpc::gimbal::TakeControlRequest,
                ::mavsdk::rpc::gimbal::TakeControlResponse>* server_unary_streamer) = 0;
    };
    template<class BaseClass> class WithStreamedUnaryMethod_ReleaseControl : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        WithStreamedUnaryMethod_ReleaseControl()
        {
            ::grpc::Service::MarkMethodStreamed(
                5,
                new ::grpc::internal::StreamedUnaryHandler<
                    ::mavsdk::rpc::gimbal::ReleaseControlRequest,
                    ::mavsdk::rpc::gimbal::ReleaseControlResponse>(
                    [this](
                        ::grpc_impl::ServerContext* context,
                        ::grpc_impl::ServerUnaryStreamer<
                            ::mavsdk::rpc::gimbal::ReleaseControlRequest,
                            ::mavsdk::rpc::gimbal::ReleaseControlResponse>* streamer) {
                        return this->StreamedReleaseControl(context, streamer);
                    }));
        }
        ~WithStreamedUnaryMethod_ReleaseControl() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable regular version of this method
        ::grpc::Status ReleaseControl(
            ::grpc::ServerContext* /*context*/,
            const ::mavsdk::rpc::gimbal::ReleaseControlRequest* /*request*/,
            ::mavsdk::rpc::gimbal::ReleaseControlResponse* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        // replace default version of method with streamed unary
        virtual ::grpc::Status StreamedReleaseControl(
            ::grpc::ServerContext* context,
            ::grpc::ServerUnaryStreamer<
                ::mavsdk::rpc::gimbal::ReleaseControlRequest,
                ::mavsdk::rpc::gimbal::ReleaseControlResponse>* server_unary_streamer) = 0;
    };
    typedef WithStreamedUnaryMethod_SetPitchAndYaw<WithStreamedUnaryMethod_SetPitchRateAndYawRate<
        WithStreamedUnaryMethod_SetMode<WithStreamedUnaryMethod_SetRoiLocation<
            WithStreamedUnaryMethod_TakeControl<WithStreamedUnaryMethod_ReleaseControl<Service>>>>>>
        StreamedUnaryService;
    template<class BaseClass> class WithSplitStreamingMethod_SubscribeControl : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}

    public:
        WithSplitStreamingMethod_SubscribeControl()
        {
            ::grpc::Service::MarkMethodStreamed(
                6,
                new ::grpc::internal::SplitServerStreamingHandler<
                    ::mavsdk::rpc::gimbal::SubscribeControlRequest,
                    ::mavsdk::rpc::gimbal::ControlResponse>(
                    [this](
                        ::grpc_impl::ServerContext* context,
                        ::grpc_impl::ServerSplitStreamer<
                            ::mavsdk::rpc::gimbal::SubscribeControlRequest,
                            ::mavsdk::rpc::gimbal::ControlResponse>* streamer) {
                        return this->StreamedSubscribeControl(context, streamer);
                    }));
        }
        ~WithSplitStreamingMethod_SubscribeControl() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable regular version of this method
        ::grpc::Status SubscribeControl(
            ::grpc::ServerContext* /*context*/,
            const ::mavsdk::rpc::gimbal::SubscribeControlRequest* /*request*/,
            ::grpc::ServerWriter<::mavsdk::rpc::gimbal::ControlResponse>* /*writer*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        // replace default version of method with split streamed
        virtual ::grpc::Status StreamedSubscribeControl(
            ::grpc::ServerContext* context,
            ::grpc::ServerSplitStreamer<
                ::mavsdk::rpc::gimbal::SubscribeControlRequest,
                ::mavsdk::rpc::gimbal::ControlResponse>* server_split_streamer) = 0;
    };
    typedef WithSplitStreamingMethod_SubscribeControl<Service> SplitStreamedService;
    typedef WithStreamedUnaryMethod_SetPitchAndYaw<WithStreamedUnaryMethod_SetPitchRateAndYawRate<
        WithStreamedUnaryMethod_SetMode<WithStreamedUnaryMethod_SetRoiLocation<
            WithStreamedUnaryMethod_TakeControl<WithStreamedUnaryMethod_ReleaseControl<
                WithSplitStreamingMethod_SubscribeControl<Service>>>>>>>
        StreamedService;
};

} // namespace gimbal
} // namespace rpc
} // namespace mavsdk

#endif // GRPC_gimbal_2fgimbal_2eproto__INCLUDED
