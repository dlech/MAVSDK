// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: log_files/log_files.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_log_5ffiles_2flog_5ffiles_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_log_5ffiles_2flog_5ffiles_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h> // IWYU pragma: export
#include <google/protobuf/extension_set.h> // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "mavsdk_options.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_log_5ffiles_2flog_5ffiles_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
} // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_log_5ffiles_2flog_5ffiles_2eproto {
    static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField
        entries[] PROTOBUF_SECTION_VARIABLE(protodesc_cold);
    static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField
        aux[] PROTOBUF_SECTION_VARIABLE(protodesc_cold);
    static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable
        schema[10] PROTOBUF_SECTION_VARIABLE(protodesc_cold);
    static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
    static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
    static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_log_5ffiles_2flog_5ffiles_2eproto;
namespace mavsdk {
namespace rpc {
namespace log_files {
class DownloadLogFileRequest;
class DownloadLogFileRequestDefaultTypeInternal;
extern DownloadLogFileRequestDefaultTypeInternal _DownloadLogFileRequest_default_instance_;
class DownloadLogFileResponse;
class DownloadLogFileResponseDefaultTypeInternal;
extern DownloadLogFileResponseDefaultTypeInternal _DownloadLogFileResponse_default_instance_;
class Entry;
class EntryDefaultTypeInternal;
extern EntryDefaultTypeInternal _Entry_default_instance_;
class EraseAllLogFilesRequest;
class EraseAllLogFilesRequestDefaultTypeInternal;
extern EraseAllLogFilesRequestDefaultTypeInternal _EraseAllLogFilesRequest_default_instance_;
class EraseAllLogFilesResponse;
class EraseAllLogFilesResponseDefaultTypeInternal;
extern EraseAllLogFilesResponseDefaultTypeInternal _EraseAllLogFilesResponse_default_instance_;
class GetEntriesRequest;
class GetEntriesRequestDefaultTypeInternal;
extern GetEntriesRequestDefaultTypeInternal _GetEntriesRequest_default_instance_;
class GetEntriesResponse;
class GetEntriesResponseDefaultTypeInternal;
extern GetEntriesResponseDefaultTypeInternal _GetEntriesResponse_default_instance_;
class LogFilesResult;
class LogFilesResultDefaultTypeInternal;
extern LogFilesResultDefaultTypeInternal _LogFilesResult_default_instance_;
class ProgressData;
class ProgressDataDefaultTypeInternal;
extern ProgressDataDefaultTypeInternal _ProgressData_default_instance_;
class SubscribeDownloadLogFileRequest;
class SubscribeDownloadLogFileRequestDefaultTypeInternal;
extern SubscribeDownloadLogFileRequestDefaultTypeInternal
    _SubscribeDownloadLogFileRequest_default_instance_;
} // namespace log_files
} // namespace rpc
} // namespace mavsdk
PROTOBUF_NAMESPACE_OPEN
template<>
::mavsdk::rpc::log_files::DownloadLogFileRequest*
Arena::CreateMaybeMessage<::mavsdk::rpc::log_files::DownloadLogFileRequest>(Arena*);
template<>
::mavsdk::rpc::log_files::DownloadLogFileResponse*
Arena::CreateMaybeMessage<::mavsdk::rpc::log_files::DownloadLogFileResponse>(Arena*);
template<>
::mavsdk::rpc::log_files::Entry* Arena::CreateMaybeMessage<::mavsdk::rpc::log_files::Entry>(Arena*);
template<>
::mavsdk::rpc::log_files::EraseAllLogFilesRequest*
Arena::CreateMaybeMessage<::mavsdk::rpc::log_files::EraseAllLogFilesRequest>(Arena*);
template<>
::mavsdk::rpc::log_files::EraseAllLogFilesResponse*
Arena::CreateMaybeMessage<::mavsdk::rpc::log_files::EraseAllLogFilesResponse>(Arena*);
template<>
::mavsdk::rpc::log_files::GetEntriesRequest*
Arena::CreateMaybeMessage<::mavsdk::rpc::log_files::GetEntriesRequest>(Arena*);
template<>
::mavsdk::rpc::log_files::GetEntriesResponse*
Arena::CreateMaybeMessage<::mavsdk::rpc::log_files::GetEntriesResponse>(Arena*);
template<>
::mavsdk::rpc::log_files::LogFilesResult*
Arena::CreateMaybeMessage<::mavsdk::rpc::log_files::LogFilesResult>(Arena*);
template<>
::mavsdk::rpc::log_files::ProgressData*
Arena::CreateMaybeMessage<::mavsdk::rpc::log_files::ProgressData>(Arena*);
template<>
::mavsdk::rpc::log_files::SubscribeDownloadLogFileRequest*
Arena::CreateMaybeMessage<::mavsdk::rpc::log_files::SubscribeDownloadLogFileRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace mavsdk {
namespace rpc {
namespace log_files {

enum LogFilesResult_Result : int {
    LogFilesResult_Result_RESULT_UNKNOWN = 0,
    LogFilesResult_Result_RESULT_SUCCESS = 1,
    LogFilesResult_Result_RESULT_NEXT = 2,
    LogFilesResult_Result_RESULT_NO_LOGFILES = 3,
    LogFilesResult_Result_RESULT_TIMEOUT = 4,
    LogFilesResult_Result_RESULT_INVALID_ARGUMENT = 5,
    LogFilesResult_Result_RESULT_FILE_OPEN_FAILED = 6,
    LogFilesResult_Result_RESULT_NO_SYSTEM = 7,
    LogFilesResult_Result_LogFilesResult_Result_INT_MIN_SENTINEL_DO_NOT_USE_ =
        std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
    LogFilesResult_Result_LogFilesResult_Result_INT_MAX_SENTINEL_DO_NOT_USE_ =
        std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool LogFilesResult_Result_IsValid(int value);
constexpr LogFilesResult_Result LogFilesResult_Result_Result_MIN =
    LogFilesResult_Result_RESULT_UNKNOWN;
constexpr LogFilesResult_Result LogFilesResult_Result_Result_MAX =
    LogFilesResult_Result_RESULT_NO_SYSTEM;
constexpr int LogFilesResult_Result_Result_ARRAYSIZE = LogFilesResult_Result_Result_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LogFilesResult_Result_descriptor();
template<typename T> inline const std::string& LogFilesResult_Result_Name(T enum_t_value)
{
    static_assert(
        ::std::is_same<T, LogFilesResult_Result>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function LogFilesResult_Result_Name.");
    return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
        LogFilesResult_Result_descriptor(), enum_t_value);
}
inline bool LogFilesResult_Result_Parse(const std::string& name, LogFilesResult_Result* value)
{
    return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LogFilesResult_Result>(
        LogFilesResult_Result_descriptor(), name, value);
}
// ===================================================================

class GetEntriesRequest PROTOBUF_FINAL : public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.log_files.GetEntriesRequest)
                                                                                  */
{
public:
    inline GetEntriesRequest() : GetEntriesRequest(nullptr){};
    virtual ~GetEntriesRequest();

    GetEntriesRequest(const GetEntriesRequest& from);
    GetEntriesRequest(GetEntriesRequest&& from) noexcept : GetEntriesRequest()
    {
        *this = ::std::move(from);
    }

    inline GetEntriesRequest& operator=(const GetEntriesRequest& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline GetEntriesRequest& operator=(GetEntriesRequest&& from) noexcept
    {
        if (GetArena() == from.GetArena()) {
            if (this != &from)
                InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() { return GetDescriptor(); }
    static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor()
    {
        return GetMetadataStatic().descriptor;
    }
    static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection()
    {
        return GetMetadataStatic().reflection;
    }
    static const GetEntriesRequest& default_instance();

    static void InitAsDefaultInstance(); // FOR INTERNAL USE ONLY
    static inline const GetEntriesRequest* internal_default_instance()
    {
        return reinterpret_cast<const GetEntriesRequest*>(&_GetEntriesRequest_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 0;

    friend void swap(GetEntriesRequest& a, GetEntriesRequest& b) { a.Swap(&b); }
    inline void Swap(GetEntriesRequest* other)
    {
        if (other == this)
            return;
        if (GetArena() == other->GetArena()) {
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(GetEntriesRequest* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetArena() == other->GetArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    inline GetEntriesRequest* New() const final
    {
        return CreateMaybeMessage<GetEntriesRequest>(nullptr);
    }

    GetEntriesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final
    {
        return CreateMaybeMessage<GetEntriesRequest>(arena);
    }
    void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
    void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
    void CopyFrom(const GetEntriesRequest& from);
    void MergeFrom(const GetEntriesRequest& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char*
    _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
        ::PROTOBUF_NAMESPACE_ID::uint8* target,
        ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final { return _cached_size_.Get(); }

private:
    inline void SharedCtor();
    inline void SharedDtor();
    void SetCachedSize(int size) const final;
    void InternalSwap(GetEntriesRequest* other);
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "mavsdk.rpc.log_files.GetEntriesRequest";
    }

protected:
    explicit GetEntriesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);

private:
    static void ArenaDtor(void* object);
    inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);

public:
    ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

private:
    static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic()
    {
        ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
            &::descriptor_table_log_5ffiles_2flog_5ffiles_2eproto);
        return ::descriptor_table_log_5ffiles_2flog_5ffiles_2eproto
            .file_level_metadata[kIndexInFileMessages];
    }

public:
    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // @@protoc_insertion_point(class_scope:mavsdk.rpc.log_files.GetEntriesRequest)
private:
    class _Internal;

    template<typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    friend struct ::TableStruct_log_5ffiles_2flog_5ffiles_2eproto;
};
// -------------------------------------------------------------------

class GetEntriesResponse PROTOBUF_FINAL : public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.log_files.GetEntriesResponse)
                                                                                   */
{
public:
    inline GetEntriesResponse() : GetEntriesResponse(nullptr){};
    virtual ~GetEntriesResponse();

    GetEntriesResponse(const GetEntriesResponse& from);
    GetEntriesResponse(GetEntriesResponse&& from) noexcept : GetEntriesResponse()
    {
        *this = ::std::move(from);
    }

    inline GetEntriesResponse& operator=(const GetEntriesResponse& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline GetEntriesResponse& operator=(GetEntriesResponse&& from) noexcept
    {
        if (GetArena() == from.GetArena()) {
            if (this != &from)
                InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() { return GetDescriptor(); }
    static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor()
    {
        return GetMetadataStatic().descriptor;
    }
    static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection()
    {
        return GetMetadataStatic().reflection;
    }
    static const GetEntriesResponse& default_instance();

    static void InitAsDefaultInstance(); // FOR INTERNAL USE ONLY
    static inline const GetEntriesResponse* internal_default_instance()
    {
        return reinterpret_cast<const GetEntriesResponse*>(&_GetEntriesResponse_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 1;

    friend void swap(GetEntriesResponse& a, GetEntriesResponse& b) { a.Swap(&b); }
    inline void Swap(GetEntriesResponse* other)
    {
        if (other == this)
            return;
        if (GetArena() == other->GetArena()) {
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(GetEntriesResponse* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetArena() == other->GetArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    inline GetEntriesResponse* New() const final
    {
        return CreateMaybeMessage<GetEntriesResponse>(nullptr);
    }

    GetEntriesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final
    {
        return CreateMaybeMessage<GetEntriesResponse>(arena);
    }
    void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
    void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
    void CopyFrom(const GetEntriesResponse& from);
    void MergeFrom(const GetEntriesResponse& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char*
    _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
        ::PROTOBUF_NAMESPACE_ID::uint8* target,
        ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final { return _cached_size_.Get(); }

private:
    inline void SharedCtor();
    inline void SharedDtor();
    void SetCachedSize(int size) const final;
    void InternalSwap(GetEntriesResponse* other);
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "mavsdk.rpc.log_files.GetEntriesResponse";
    }

protected:
    explicit GetEntriesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);

private:
    static void ArenaDtor(void* object);
    inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);

public:
    ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

private:
    static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic()
    {
        ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
            &::descriptor_table_log_5ffiles_2flog_5ffiles_2eproto);
        return ::descriptor_table_log_5ffiles_2flog_5ffiles_2eproto
            .file_level_metadata[kIndexInFileMessages];
    }

public:
    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kEntriesFieldNumber = 2,
        kLogFilesResultFieldNumber = 1,
    };
    // repeated .mavsdk.rpc.log_files.Entry entries = 2;
    int entries_size() const;

private:
    int _internal_entries_size() const;

public:
    void clear_entries();
    ::mavsdk::rpc::log_files::Entry* mutable_entries(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::mavsdk::rpc::log_files::Entry>* mutable_entries();

private:
    const ::mavsdk::rpc::log_files::Entry& _internal_entries(int index) const;
    ::mavsdk::rpc::log_files::Entry* _internal_add_entries();

public:
    const ::mavsdk::rpc::log_files::Entry& entries(int index) const;
    ::mavsdk::rpc::log_files::Entry* add_entries();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::mavsdk::rpc::log_files::Entry>&
    entries() const;

    // .mavsdk.rpc.log_files.LogFilesResult log_files_result = 1;
    bool has_log_files_result() const;

private:
    bool _internal_has_log_files_result() const;

public:
    void clear_log_files_result();
    const ::mavsdk::rpc::log_files::LogFilesResult& log_files_result() const;
    ::mavsdk::rpc::log_files::LogFilesResult* release_log_files_result();
    ::mavsdk::rpc::log_files::LogFilesResult* mutable_log_files_result();
    void set_allocated_log_files_result(::mavsdk::rpc::log_files::LogFilesResult* log_files_result);

private:
    const ::mavsdk::rpc::log_files::LogFilesResult& _internal_log_files_result() const;
    ::mavsdk::rpc::log_files::LogFilesResult* _internal_mutable_log_files_result();

public:
    void unsafe_arena_set_allocated_log_files_result(
        ::mavsdk::rpc::log_files::LogFilesResult* log_files_result);
    ::mavsdk::rpc::log_files::LogFilesResult* unsafe_arena_release_log_files_result();

    // @@protoc_insertion_point(class_scope:mavsdk.rpc.log_files.GetEntriesResponse)
private:
    class _Internal;

    template<typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::mavsdk::rpc::log_files::Entry> entries_;
    ::mavsdk::rpc::log_files::LogFilesResult* log_files_result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    friend struct ::TableStruct_log_5ffiles_2flog_5ffiles_2eproto;
};
// -------------------------------------------------------------------

class SubscribeDownloadLogFileRequest PROTOBUF_FINAL : public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.log_files.SubscribeDownloadLogFileRequest)
                                                                                                */
{
public:
    inline SubscribeDownloadLogFileRequest() : SubscribeDownloadLogFileRequest(nullptr){};
    virtual ~SubscribeDownloadLogFileRequest();

    SubscribeDownloadLogFileRequest(const SubscribeDownloadLogFileRequest& from);
    SubscribeDownloadLogFileRequest(SubscribeDownloadLogFileRequest&& from) noexcept :
        SubscribeDownloadLogFileRequest()
    {
        *this = ::std::move(from);
    }

    inline SubscribeDownloadLogFileRequest& operator=(const SubscribeDownloadLogFileRequest& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline SubscribeDownloadLogFileRequest&
    operator=(SubscribeDownloadLogFileRequest&& from) noexcept
    {
        if (GetArena() == from.GetArena()) {
            if (this != &from)
                InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() { return GetDescriptor(); }
    static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor()
    {
        return GetMetadataStatic().descriptor;
    }
    static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection()
    {
        return GetMetadataStatic().reflection;
    }
    static const SubscribeDownloadLogFileRequest& default_instance();

    static void InitAsDefaultInstance(); // FOR INTERNAL USE ONLY
    static inline const SubscribeDownloadLogFileRequest* internal_default_instance()
    {
        return reinterpret_cast<const SubscribeDownloadLogFileRequest*>(
            &_SubscribeDownloadLogFileRequest_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 2;

    friend void swap(SubscribeDownloadLogFileRequest& a, SubscribeDownloadLogFileRequest& b)
    {
        a.Swap(&b);
    }
    inline void Swap(SubscribeDownloadLogFileRequest* other)
    {
        if (other == this)
            return;
        if (GetArena() == other->GetArena()) {
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(SubscribeDownloadLogFileRequest* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetArena() == other->GetArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    inline SubscribeDownloadLogFileRequest* New() const final
    {
        return CreateMaybeMessage<SubscribeDownloadLogFileRequest>(nullptr);
    }

    SubscribeDownloadLogFileRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final
    {
        return CreateMaybeMessage<SubscribeDownloadLogFileRequest>(arena);
    }
    void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
    void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
    void CopyFrom(const SubscribeDownloadLogFileRequest& from);
    void MergeFrom(const SubscribeDownloadLogFileRequest& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char*
    _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
        ::PROTOBUF_NAMESPACE_ID::uint8* target,
        ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final { return _cached_size_.Get(); }

private:
    inline void SharedCtor();
    inline void SharedDtor();
    void SetCachedSize(int size) const final;
    void InternalSwap(SubscribeDownloadLogFileRequest* other);
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "mavsdk.rpc.log_files.SubscribeDownloadLogFileRequest";
    }

protected:
    explicit SubscribeDownloadLogFileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);

private:
    static void ArenaDtor(void* object);
    inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);

public:
    ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

private:
    static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic()
    {
        ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
            &::descriptor_table_log_5ffiles_2flog_5ffiles_2eproto);
        return ::descriptor_table_log_5ffiles_2flog_5ffiles_2eproto
            .file_level_metadata[kIndexInFileMessages];
    }

public:
    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kPathFieldNumber = 2,
        kEntryFieldNumber = 1,
    };
    // string path = 2;
    void clear_path();
    const std::string& path() const;
    void set_path(const std::string& value);
    void set_path(std::string&& value);
    void set_path(const char* value);
    void set_path(const char* value, size_t size);
    std::string* mutable_path();
    std::string* release_path();
    void set_allocated_path(std::string* path);
    GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
                                       "    string fields are deprecated and will be removed in a"
                                       "    future release.")
    std::string* unsafe_arena_release_path();
    GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
                                       "    string fields are deprecated and will be removed in a"
                                       "    future release.")
    void unsafe_arena_set_allocated_path(std::string* path);

private:
    const std::string& _internal_path() const;
    void _internal_set_path(const std::string& value);
    std::string* _internal_mutable_path();

public:
    // .mavsdk.rpc.log_files.Entry entry = 1;
    bool has_entry() const;

private:
    bool _internal_has_entry() const;

public:
    void clear_entry();
    const ::mavsdk::rpc::log_files::Entry& entry() const;
    ::mavsdk::rpc::log_files::Entry* release_entry();
    ::mavsdk::rpc::log_files::Entry* mutable_entry();
    void set_allocated_entry(::mavsdk::rpc::log_files::Entry* entry);

private:
    const ::mavsdk::rpc::log_files::Entry& _internal_entry() const;
    ::mavsdk::rpc::log_files::Entry* _internal_mutable_entry();

public:
    void unsafe_arena_set_allocated_entry(::mavsdk::rpc::log_files::Entry* entry);
    ::mavsdk::rpc::log_files::Entry* unsafe_arena_release_entry();

    // @@protoc_insertion_point(class_scope:mavsdk.rpc.log_files.SubscribeDownloadLogFileRequest)
private:
    class _Internal;

    template<typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    ::mavsdk::rpc::log_files::Entry* entry_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    friend struct ::TableStruct_log_5ffiles_2flog_5ffiles_2eproto;
};
// -------------------------------------------------------------------

class DownloadLogFileResponse PROTOBUF_FINAL : public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.log_files.DownloadLogFileResponse)
                                                                                        */
{
public:
    inline DownloadLogFileResponse() : DownloadLogFileResponse(nullptr){};
    virtual ~DownloadLogFileResponse();

    DownloadLogFileResponse(const DownloadLogFileResponse& from);
    DownloadLogFileResponse(DownloadLogFileResponse&& from) noexcept : DownloadLogFileResponse()
    {
        *this = ::std::move(from);
    }

    inline DownloadLogFileResponse& operator=(const DownloadLogFileResponse& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline DownloadLogFileResponse& operator=(DownloadLogFileResponse&& from) noexcept
    {
        if (GetArena() == from.GetArena()) {
            if (this != &from)
                InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() { return GetDescriptor(); }
    static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor()
    {
        return GetMetadataStatic().descriptor;
    }
    static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection()
    {
        return GetMetadataStatic().reflection;
    }
    static const DownloadLogFileResponse& default_instance();

    static void InitAsDefaultInstance(); // FOR INTERNAL USE ONLY
    static inline const DownloadLogFileResponse* internal_default_instance()
    {
        return reinterpret_cast<const DownloadLogFileResponse*>(
            &_DownloadLogFileResponse_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 3;

    friend void swap(DownloadLogFileResponse& a, DownloadLogFileResponse& b) { a.Swap(&b); }
    inline void Swap(DownloadLogFileResponse* other)
    {
        if (other == this)
            return;
        if (GetArena() == other->GetArena()) {
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(DownloadLogFileResponse* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetArena() == other->GetArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    inline DownloadLogFileResponse* New() const final
    {
        return CreateMaybeMessage<DownloadLogFileResponse>(nullptr);
    }

    DownloadLogFileResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final
    {
        return CreateMaybeMessage<DownloadLogFileResponse>(arena);
    }
    void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
    void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
    void CopyFrom(const DownloadLogFileResponse& from);
    void MergeFrom(const DownloadLogFileResponse& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char*
    _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
        ::PROTOBUF_NAMESPACE_ID::uint8* target,
        ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final { return _cached_size_.Get(); }

private:
    inline void SharedCtor();
    inline void SharedDtor();
    void SetCachedSize(int size) const final;
    void InternalSwap(DownloadLogFileResponse* other);
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "mavsdk.rpc.log_files.DownloadLogFileResponse";
    }

protected:
    explicit DownloadLogFileResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);

private:
    static void ArenaDtor(void* object);
    inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);

public:
    ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

private:
    static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic()
    {
        ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
            &::descriptor_table_log_5ffiles_2flog_5ffiles_2eproto);
        return ::descriptor_table_log_5ffiles_2flog_5ffiles_2eproto
            .file_level_metadata[kIndexInFileMessages];
    }

public:
    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kLogFilesResultFieldNumber = 1,
        kProgressFieldNumber = 2,
    };
    // .mavsdk.rpc.log_files.LogFilesResult log_files_result = 1;
    bool has_log_files_result() const;

private:
    bool _internal_has_log_files_result() const;

public:
    void clear_log_files_result();
    const ::mavsdk::rpc::log_files::LogFilesResult& log_files_result() const;
    ::mavsdk::rpc::log_files::LogFilesResult* release_log_files_result();
    ::mavsdk::rpc::log_files::LogFilesResult* mutable_log_files_result();
    void set_allocated_log_files_result(::mavsdk::rpc::log_files::LogFilesResult* log_files_result);

private:
    const ::mavsdk::rpc::log_files::LogFilesResult& _internal_log_files_result() const;
    ::mavsdk::rpc::log_files::LogFilesResult* _internal_mutable_log_files_result();

public:
    void unsafe_arena_set_allocated_log_files_result(
        ::mavsdk::rpc::log_files::LogFilesResult* log_files_result);
    ::mavsdk::rpc::log_files::LogFilesResult* unsafe_arena_release_log_files_result();

    // .mavsdk.rpc.log_files.ProgressData progress = 2;
    bool has_progress() const;

private:
    bool _internal_has_progress() const;

public:
    void clear_progress();
    const ::mavsdk::rpc::log_files::ProgressData& progress() const;
    ::mavsdk::rpc::log_files::ProgressData* release_progress();
    ::mavsdk::rpc::log_files::ProgressData* mutable_progress();
    void set_allocated_progress(::mavsdk::rpc::log_files::ProgressData* progress);

private:
    const ::mavsdk::rpc::log_files::ProgressData& _internal_progress() const;
    ::mavsdk::rpc::log_files::ProgressData* _internal_mutable_progress();

public:
    void unsafe_arena_set_allocated_progress(::mavsdk::rpc::log_files::ProgressData* progress);
    ::mavsdk::rpc::log_files::ProgressData* unsafe_arena_release_progress();

    // @@protoc_insertion_point(class_scope:mavsdk.rpc.log_files.DownloadLogFileResponse)
private:
    class _Internal;

    template<typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    ::mavsdk::rpc::log_files::LogFilesResult* log_files_result_;
    ::mavsdk::rpc::log_files::ProgressData* progress_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    friend struct ::TableStruct_log_5ffiles_2flog_5ffiles_2eproto;
};
// -------------------------------------------------------------------

class DownloadLogFileRequest PROTOBUF_FINAL : public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.log_files.DownloadLogFileRequest)
                                                                                       */
{
public:
    inline DownloadLogFileRequest() : DownloadLogFileRequest(nullptr){};
    virtual ~DownloadLogFileRequest();

    DownloadLogFileRequest(const DownloadLogFileRequest& from);
    DownloadLogFileRequest(DownloadLogFileRequest&& from) noexcept : DownloadLogFileRequest()
    {
        *this = ::std::move(from);
    }

    inline DownloadLogFileRequest& operator=(const DownloadLogFileRequest& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline DownloadLogFileRequest& operator=(DownloadLogFileRequest&& from) noexcept
    {
        if (GetArena() == from.GetArena()) {
            if (this != &from)
                InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() { return GetDescriptor(); }
    static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor()
    {
        return GetMetadataStatic().descriptor;
    }
    static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection()
    {
        return GetMetadataStatic().reflection;
    }
    static const DownloadLogFileRequest& default_instance();

    static void InitAsDefaultInstance(); // FOR INTERNAL USE ONLY
    static inline const DownloadLogFileRequest* internal_default_instance()
    {
        return reinterpret_cast<const DownloadLogFileRequest*>(
            &_DownloadLogFileRequest_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 4;

    friend void swap(DownloadLogFileRequest& a, DownloadLogFileRequest& b) { a.Swap(&b); }
    inline void Swap(DownloadLogFileRequest* other)
    {
        if (other == this)
            return;
        if (GetArena() == other->GetArena()) {
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(DownloadLogFileRequest* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetArena() == other->GetArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    inline DownloadLogFileRequest* New() const final
    {
        return CreateMaybeMessage<DownloadLogFileRequest>(nullptr);
    }

    DownloadLogFileRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final
    {
        return CreateMaybeMessage<DownloadLogFileRequest>(arena);
    }
    void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
    void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
    void CopyFrom(const DownloadLogFileRequest& from);
    void MergeFrom(const DownloadLogFileRequest& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char*
    _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
        ::PROTOBUF_NAMESPACE_ID::uint8* target,
        ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final { return _cached_size_.Get(); }

private:
    inline void SharedCtor();
    inline void SharedDtor();
    void SetCachedSize(int size) const final;
    void InternalSwap(DownloadLogFileRequest* other);
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "mavsdk.rpc.log_files.DownloadLogFileRequest";
    }

protected:
    explicit DownloadLogFileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);

private:
    static void ArenaDtor(void* object);
    inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);

public:
    ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

private:
    static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic()
    {
        ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
            &::descriptor_table_log_5ffiles_2flog_5ffiles_2eproto);
        return ::descriptor_table_log_5ffiles_2flog_5ffiles_2eproto
            .file_level_metadata[kIndexInFileMessages];
    }

public:
    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kPathFieldNumber = 2,
        kEntryFieldNumber = 1,
    };
    // string path = 2;
    void clear_path();
    const std::string& path() const;
    void set_path(const std::string& value);
    void set_path(std::string&& value);
    void set_path(const char* value);
    void set_path(const char* value, size_t size);
    std::string* mutable_path();
    std::string* release_path();
    void set_allocated_path(std::string* path);
    GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
                                       "    string fields are deprecated and will be removed in a"
                                       "    future release.")
    std::string* unsafe_arena_release_path();
    GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
                                       "    string fields are deprecated and will be removed in a"
                                       "    future release.")
    void unsafe_arena_set_allocated_path(std::string* path);

private:
    const std::string& _internal_path() const;
    void _internal_set_path(const std::string& value);
    std::string* _internal_mutable_path();

public:
    // .mavsdk.rpc.log_files.Entry entry = 1;
    bool has_entry() const;

private:
    bool _internal_has_entry() const;

public:
    void clear_entry();
    const ::mavsdk::rpc::log_files::Entry& entry() const;
    ::mavsdk::rpc::log_files::Entry* release_entry();
    ::mavsdk::rpc::log_files::Entry* mutable_entry();
    void set_allocated_entry(::mavsdk::rpc::log_files::Entry* entry);

private:
    const ::mavsdk::rpc::log_files::Entry& _internal_entry() const;
    ::mavsdk::rpc::log_files::Entry* _internal_mutable_entry();

public:
    void unsafe_arena_set_allocated_entry(::mavsdk::rpc::log_files::Entry* entry);
    ::mavsdk::rpc::log_files::Entry* unsafe_arena_release_entry();

    // @@protoc_insertion_point(class_scope:mavsdk.rpc.log_files.DownloadLogFileRequest)
private:
    class _Internal;

    template<typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    ::mavsdk::rpc::log_files::Entry* entry_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    friend struct ::TableStruct_log_5ffiles_2flog_5ffiles_2eproto;
};
// -------------------------------------------------------------------

class EraseAllLogFilesRequest PROTOBUF_FINAL : public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.log_files.EraseAllLogFilesRequest)
                                                                                        */
{
public:
    inline EraseAllLogFilesRequest() : EraseAllLogFilesRequest(nullptr){};
    virtual ~EraseAllLogFilesRequest();

    EraseAllLogFilesRequest(const EraseAllLogFilesRequest& from);
    EraseAllLogFilesRequest(EraseAllLogFilesRequest&& from) noexcept : EraseAllLogFilesRequest()
    {
        *this = ::std::move(from);
    }

    inline EraseAllLogFilesRequest& operator=(const EraseAllLogFilesRequest& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline EraseAllLogFilesRequest& operator=(EraseAllLogFilesRequest&& from) noexcept
    {
        if (GetArena() == from.GetArena()) {
            if (this != &from)
                InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() { return GetDescriptor(); }
    static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor()
    {
        return GetMetadataStatic().descriptor;
    }
    static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection()
    {
        return GetMetadataStatic().reflection;
    }
    static const EraseAllLogFilesRequest& default_instance();

    static void InitAsDefaultInstance(); // FOR INTERNAL USE ONLY
    static inline const EraseAllLogFilesRequest* internal_default_instance()
    {
        return reinterpret_cast<const EraseAllLogFilesRequest*>(
            &_EraseAllLogFilesRequest_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 5;

    friend void swap(EraseAllLogFilesRequest& a, EraseAllLogFilesRequest& b) { a.Swap(&b); }
    inline void Swap(EraseAllLogFilesRequest* other)
    {
        if (other == this)
            return;
        if (GetArena() == other->GetArena()) {
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(EraseAllLogFilesRequest* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetArena() == other->GetArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    inline EraseAllLogFilesRequest* New() const final
    {
        return CreateMaybeMessage<EraseAllLogFilesRequest>(nullptr);
    }

    EraseAllLogFilesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final
    {
        return CreateMaybeMessage<EraseAllLogFilesRequest>(arena);
    }
    void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
    void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
    void CopyFrom(const EraseAllLogFilesRequest& from);
    void MergeFrom(const EraseAllLogFilesRequest& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char*
    _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
        ::PROTOBUF_NAMESPACE_ID::uint8* target,
        ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final { return _cached_size_.Get(); }

private:
    inline void SharedCtor();
    inline void SharedDtor();
    void SetCachedSize(int size) const final;
    void InternalSwap(EraseAllLogFilesRequest* other);
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "mavsdk.rpc.log_files.EraseAllLogFilesRequest";
    }

protected:
    explicit EraseAllLogFilesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);

private:
    static void ArenaDtor(void* object);
    inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);

public:
    ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

private:
    static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic()
    {
        ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
            &::descriptor_table_log_5ffiles_2flog_5ffiles_2eproto);
        return ::descriptor_table_log_5ffiles_2flog_5ffiles_2eproto
            .file_level_metadata[kIndexInFileMessages];
    }

public:
    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // @@protoc_insertion_point(class_scope:mavsdk.rpc.log_files.EraseAllLogFilesRequest)
private:
    class _Internal;

    template<typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    friend struct ::TableStruct_log_5ffiles_2flog_5ffiles_2eproto;
};
// -------------------------------------------------------------------

class EraseAllLogFilesResponse PROTOBUF_FINAL : public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.log_files.EraseAllLogFilesResponse)
                                                                                         */
{
public:
    inline EraseAllLogFilesResponse() : EraseAllLogFilesResponse(nullptr){};
    virtual ~EraseAllLogFilesResponse();

    EraseAllLogFilesResponse(const EraseAllLogFilesResponse& from);
    EraseAllLogFilesResponse(EraseAllLogFilesResponse&& from) noexcept : EraseAllLogFilesResponse()
    {
        *this = ::std::move(from);
    }

    inline EraseAllLogFilesResponse& operator=(const EraseAllLogFilesResponse& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline EraseAllLogFilesResponse& operator=(EraseAllLogFilesResponse&& from) noexcept
    {
        if (GetArena() == from.GetArena()) {
            if (this != &from)
                InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() { return GetDescriptor(); }
    static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor()
    {
        return GetMetadataStatic().descriptor;
    }
    static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection()
    {
        return GetMetadataStatic().reflection;
    }
    static const EraseAllLogFilesResponse& default_instance();

    static void InitAsDefaultInstance(); // FOR INTERNAL USE ONLY
    static inline const EraseAllLogFilesResponse* internal_default_instance()
    {
        return reinterpret_cast<const EraseAllLogFilesResponse*>(
            &_EraseAllLogFilesResponse_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 6;

    friend void swap(EraseAllLogFilesResponse& a, EraseAllLogFilesResponse& b) { a.Swap(&b); }
    inline void Swap(EraseAllLogFilesResponse* other)
    {
        if (other == this)
            return;
        if (GetArena() == other->GetArena()) {
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(EraseAllLogFilesResponse* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetArena() == other->GetArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    inline EraseAllLogFilesResponse* New() const final
    {
        return CreateMaybeMessage<EraseAllLogFilesResponse>(nullptr);
    }

    EraseAllLogFilesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final
    {
        return CreateMaybeMessage<EraseAllLogFilesResponse>(arena);
    }
    void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
    void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
    void CopyFrom(const EraseAllLogFilesResponse& from);
    void MergeFrom(const EraseAllLogFilesResponse& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char*
    _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
        ::PROTOBUF_NAMESPACE_ID::uint8* target,
        ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final { return _cached_size_.Get(); }

private:
    inline void SharedCtor();
    inline void SharedDtor();
    void SetCachedSize(int size) const final;
    void InternalSwap(EraseAllLogFilesResponse* other);
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "mavsdk.rpc.log_files.EraseAllLogFilesResponse";
    }

protected:
    explicit EraseAllLogFilesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);

private:
    static void ArenaDtor(void* object);
    inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);

public:
    ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

private:
    static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic()
    {
        ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
            &::descriptor_table_log_5ffiles_2flog_5ffiles_2eproto);
        return ::descriptor_table_log_5ffiles_2flog_5ffiles_2eproto
            .file_level_metadata[kIndexInFileMessages];
    }

public:
    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kLogFilesResultFieldNumber = 1,
    };
    // .mavsdk.rpc.log_files.LogFilesResult log_files_result = 1;
    bool has_log_files_result() const;

private:
    bool _internal_has_log_files_result() const;

public:
    void clear_log_files_result();
    const ::mavsdk::rpc::log_files::LogFilesResult& log_files_result() const;
    ::mavsdk::rpc::log_files::LogFilesResult* release_log_files_result();
    ::mavsdk::rpc::log_files::LogFilesResult* mutable_log_files_result();
    void set_allocated_log_files_result(::mavsdk::rpc::log_files::LogFilesResult* log_files_result);

private:
    const ::mavsdk::rpc::log_files::LogFilesResult& _internal_log_files_result() const;
    ::mavsdk::rpc::log_files::LogFilesResult* _internal_mutable_log_files_result();

public:
    void unsafe_arena_set_allocated_log_files_result(
        ::mavsdk::rpc::log_files::LogFilesResult* log_files_result);
    ::mavsdk::rpc::log_files::LogFilesResult* unsafe_arena_release_log_files_result();

    // @@protoc_insertion_point(class_scope:mavsdk.rpc.log_files.EraseAllLogFilesResponse)
private:
    class _Internal;

    template<typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    ::mavsdk::rpc::log_files::LogFilesResult* log_files_result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    friend struct ::TableStruct_log_5ffiles_2flog_5ffiles_2eproto;
};
// -------------------------------------------------------------------

class ProgressData PROTOBUF_FINAL : public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.log_files.ProgressData)
                                                                             */
{
public:
    inline ProgressData() : ProgressData(nullptr){};
    virtual ~ProgressData();

    ProgressData(const ProgressData& from);
    ProgressData(ProgressData&& from) noexcept : ProgressData() { *this = ::std::move(from); }

    inline ProgressData& operator=(const ProgressData& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ProgressData& operator=(ProgressData&& from) noexcept
    {
        if (GetArena() == from.GetArena()) {
            if (this != &from)
                InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() { return GetDescriptor(); }
    static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor()
    {
        return GetMetadataStatic().descriptor;
    }
    static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection()
    {
        return GetMetadataStatic().reflection;
    }
    static const ProgressData& default_instance();

    static void InitAsDefaultInstance(); // FOR INTERNAL USE ONLY
    static inline const ProgressData* internal_default_instance()
    {
        return reinterpret_cast<const ProgressData*>(&_ProgressData_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 7;

    friend void swap(ProgressData& a, ProgressData& b) { a.Swap(&b); }
    inline void Swap(ProgressData* other)
    {
        if (other == this)
            return;
        if (GetArena() == other->GetArena()) {
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ProgressData* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetArena() == other->GetArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    inline ProgressData* New() const final { return CreateMaybeMessage<ProgressData>(nullptr); }

    ProgressData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final
    {
        return CreateMaybeMessage<ProgressData>(arena);
    }
    void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
    void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
    void CopyFrom(const ProgressData& from);
    void MergeFrom(const ProgressData& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char*
    _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
        ::PROTOBUF_NAMESPACE_ID::uint8* target,
        ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final { return _cached_size_.Get(); }

private:
    inline void SharedCtor();
    inline void SharedDtor();
    void SetCachedSize(int size) const final;
    void InternalSwap(ProgressData* other);
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "mavsdk.rpc.log_files.ProgressData";
    }

protected:
    explicit ProgressData(::PROTOBUF_NAMESPACE_ID::Arena* arena);

private:
    static void ArenaDtor(void* object);
    inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);

public:
    ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

private:
    static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic()
    {
        ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
            &::descriptor_table_log_5ffiles_2flog_5ffiles_2eproto);
        return ::descriptor_table_log_5ffiles_2flog_5ffiles_2eproto
            .file_level_metadata[kIndexInFileMessages];
    }

public:
    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kProgressFieldNumber = 1,
    };
    // float progress = 1 [(.mavsdk.options.default_value) = "NaN"];
    void clear_progress();
    float progress() const;
    void set_progress(float value);

private:
    float _internal_progress() const;
    void _internal_set_progress(float value);

public:
    // @@protoc_insertion_point(class_scope:mavsdk.rpc.log_files.ProgressData)
private:
    class _Internal;

    template<typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    float progress_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    friend struct ::TableStruct_log_5ffiles_2flog_5ffiles_2eproto;
};
// -------------------------------------------------------------------

class Entry PROTOBUF_FINAL
    : public ::PROTOBUF_NAMESPACE_ID::
          Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.log_files.Entry) */ {
public:
    inline Entry() : Entry(nullptr){};
    virtual ~Entry();

    Entry(const Entry& from);
    Entry(Entry&& from) noexcept : Entry() { *this = ::std::move(from); }

    inline Entry& operator=(const Entry& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline Entry& operator=(Entry&& from) noexcept
    {
        if (GetArena() == from.GetArena()) {
            if (this != &from)
                InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() { return GetDescriptor(); }
    static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor()
    {
        return GetMetadataStatic().descriptor;
    }
    static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection()
    {
        return GetMetadataStatic().reflection;
    }
    static const Entry& default_instance();

    static void InitAsDefaultInstance(); // FOR INTERNAL USE ONLY
    static inline const Entry* internal_default_instance()
    {
        return reinterpret_cast<const Entry*>(&_Entry_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 8;

    friend void swap(Entry& a, Entry& b) { a.Swap(&b); }
    inline void Swap(Entry* other)
    {
        if (other == this)
            return;
        if (GetArena() == other->GetArena()) {
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(Entry* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetArena() == other->GetArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    inline Entry* New() const final { return CreateMaybeMessage<Entry>(nullptr); }

    Entry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final
    {
        return CreateMaybeMessage<Entry>(arena);
    }
    void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
    void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
    void CopyFrom(const Entry& from);
    void MergeFrom(const Entry& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char*
    _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
        ::PROTOBUF_NAMESPACE_ID::uint8* target,
        ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final { return _cached_size_.Get(); }

private:
    inline void SharedCtor();
    inline void SharedDtor();
    void SetCachedSize(int size) const final;
    void InternalSwap(Entry* other);
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "mavsdk.rpc.log_files.Entry";
    }

protected:
    explicit Entry(::PROTOBUF_NAMESPACE_ID::Arena* arena);

private:
    static void ArenaDtor(void* object);
    inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);

public:
    ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

private:
    static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic()
    {
        ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
            &::descriptor_table_log_5ffiles_2flog_5ffiles_2eproto);
        return ::descriptor_table_log_5ffiles_2flog_5ffiles_2eproto
            .file_level_metadata[kIndexInFileMessages];
    }

public:
    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kDateFieldNumber = 2,
        kIdFieldNumber = 1,
        kSizeBytesFieldNumber = 3,
    };
    // string date = 2;
    void clear_date();
    const std::string& date() const;
    void set_date(const std::string& value);
    void set_date(std::string&& value);
    void set_date(const char* value);
    void set_date(const char* value, size_t size);
    std::string* mutable_date();
    std::string* release_date();
    void set_allocated_date(std::string* date);
    GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
                                       "    string fields are deprecated and will be removed in a"
                                       "    future release.")
    std::string* unsafe_arena_release_date();
    GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
                                       "    string fields are deprecated and will be removed in a"
                                       "    future release.")
    void unsafe_arena_set_allocated_date(std::string* date);

private:
    const std::string& _internal_date() const;
    void _internal_set_date(const std::string& value);
    std::string* _internal_mutable_date();

public:
    // uint32 id = 1;
    void clear_id();
    ::PROTOBUF_NAMESPACE_ID::uint32 id() const;
    void set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);

private:
    ::PROTOBUF_NAMESPACE_ID::uint32 _internal_id() const;
    void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);

public:
    // uint32 size_bytes = 3;
    void clear_size_bytes();
    ::PROTOBUF_NAMESPACE_ID::uint32 size_bytes() const;
    void set_size_bytes(::PROTOBUF_NAMESPACE_ID::uint32 value);

private:
    ::PROTOBUF_NAMESPACE_ID::uint32 _internal_size_bytes() const;
    void _internal_set_size_bytes(::PROTOBUF_NAMESPACE_ID::uint32 value);

public:
    // @@protoc_insertion_point(class_scope:mavsdk.rpc.log_files.Entry)
private:
    class _Internal;

    template<typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr date_;
    ::PROTOBUF_NAMESPACE_ID::uint32 id_;
    ::PROTOBUF_NAMESPACE_ID::uint32 size_bytes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    friend struct ::TableStruct_log_5ffiles_2flog_5ffiles_2eproto;
};
// -------------------------------------------------------------------

class LogFilesResult PROTOBUF_FINAL : public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.log_files.LogFilesResult)
                                                                               */
{
public:
    inline LogFilesResult() : LogFilesResult(nullptr){};
    virtual ~LogFilesResult();

    LogFilesResult(const LogFilesResult& from);
    LogFilesResult(LogFilesResult&& from) noexcept : LogFilesResult() { *this = ::std::move(from); }

    inline LogFilesResult& operator=(const LogFilesResult& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline LogFilesResult& operator=(LogFilesResult&& from) noexcept
    {
        if (GetArena() == from.GetArena()) {
            if (this != &from)
                InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() { return GetDescriptor(); }
    static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor()
    {
        return GetMetadataStatic().descriptor;
    }
    static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection()
    {
        return GetMetadataStatic().reflection;
    }
    static const LogFilesResult& default_instance();

    static void InitAsDefaultInstance(); // FOR INTERNAL USE ONLY
    static inline const LogFilesResult* internal_default_instance()
    {
        return reinterpret_cast<const LogFilesResult*>(&_LogFilesResult_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 9;

    friend void swap(LogFilesResult& a, LogFilesResult& b) { a.Swap(&b); }
    inline void Swap(LogFilesResult* other)
    {
        if (other == this)
            return;
        if (GetArena() == other->GetArena()) {
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(LogFilesResult* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetArena() == other->GetArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    inline LogFilesResult* New() const final { return CreateMaybeMessage<LogFilesResult>(nullptr); }

    LogFilesResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final
    {
        return CreateMaybeMessage<LogFilesResult>(arena);
    }
    void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
    void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
    void CopyFrom(const LogFilesResult& from);
    void MergeFrom(const LogFilesResult& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char*
    _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
        ::PROTOBUF_NAMESPACE_ID::uint8* target,
        ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final { return _cached_size_.Get(); }

private:
    inline void SharedCtor();
    inline void SharedDtor();
    void SetCachedSize(int size) const final;
    void InternalSwap(LogFilesResult* other);
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "mavsdk.rpc.log_files.LogFilesResult";
    }

protected:
    explicit LogFilesResult(::PROTOBUF_NAMESPACE_ID::Arena* arena);

private:
    static void ArenaDtor(void* object);
    inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);

public:
    ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

private:
    static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic()
    {
        ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
            &::descriptor_table_log_5ffiles_2flog_5ffiles_2eproto);
        return ::descriptor_table_log_5ffiles_2flog_5ffiles_2eproto
            .file_level_metadata[kIndexInFileMessages];
    }

public:
    // nested types ----------------------------------------------------

    typedef LogFilesResult_Result Result;
    static constexpr Result RESULT_UNKNOWN = LogFilesResult_Result_RESULT_UNKNOWN;
    static constexpr Result RESULT_SUCCESS = LogFilesResult_Result_RESULT_SUCCESS;
    static constexpr Result RESULT_NEXT = LogFilesResult_Result_RESULT_NEXT;
    static constexpr Result RESULT_NO_LOGFILES = LogFilesResult_Result_RESULT_NO_LOGFILES;
    static constexpr Result RESULT_TIMEOUT = LogFilesResult_Result_RESULT_TIMEOUT;
    static constexpr Result RESULT_INVALID_ARGUMENT = LogFilesResult_Result_RESULT_INVALID_ARGUMENT;
    static constexpr Result RESULT_FILE_OPEN_FAILED = LogFilesResult_Result_RESULT_FILE_OPEN_FAILED;
    static constexpr Result RESULT_NO_SYSTEM = LogFilesResult_Result_RESULT_NO_SYSTEM;
    static inline bool Result_IsValid(int value) { return LogFilesResult_Result_IsValid(value); }
    static constexpr Result Result_MIN = LogFilesResult_Result_Result_MIN;
    static constexpr Result Result_MAX = LogFilesResult_Result_Result_MAX;
    static constexpr int Result_ARRAYSIZE = LogFilesResult_Result_Result_ARRAYSIZE;
    static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Result_descriptor()
    {
        return LogFilesResult_Result_descriptor();
    }
    template<typename T> static inline const std::string& Result_Name(T enum_t_value)
    {
        static_assert(
            ::std::is_same<T, Result>::value || ::std::is_integral<T>::value,
            "Incorrect type passed to function Result_Name.");
        return LogFilesResult_Result_Name(enum_t_value);
    }
    static inline bool Result_Parse(const std::string& name, Result* value)
    {
        return LogFilesResult_Result_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    enum : int {
        kResultStrFieldNumber = 2,
        kResultFieldNumber = 1,
    };
    // string result_str = 2;
    void clear_result_str();
    const std::string& result_str() const;
    void set_result_str(const std::string& value);
    void set_result_str(std::string&& value);
    void set_result_str(const char* value);
    void set_result_str(const char* value, size_t size);
    std::string* mutable_result_str();
    std::string* release_result_str();
    void set_allocated_result_str(std::string* result_str);
    GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
                                       "    string fields are deprecated and will be removed in a"
                                       "    future release.")
    std::string* unsafe_arena_release_result_str();
    GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
                                       "    string fields are deprecated and will be removed in a"
                                       "    future release.")
    void unsafe_arena_set_allocated_result_str(std::string* result_str);

private:
    const std::string& _internal_result_str() const;
    void _internal_set_result_str(const std::string& value);
    std::string* _internal_mutable_result_str();

public:
    // .mavsdk.rpc.log_files.LogFilesResult.Result result = 1;
    void clear_result();
    ::mavsdk::rpc::log_files::LogFilesResult_Result result() const;
    void set_result(::mavsdk::rpc::log_files::LogFilesResult_Result value);

private:
    ::mavsdk::rpc::log_files::LogFilesResult_Result _internal_result() const;
    void _internal_set_result(::mavsdk::rpc::log_files::LogFilesResult_Result value);

public:
    // @@protoc_insertion_point(class_scope:mavsdk.rpc.log_files.LogFilesResult)
private:
    class _Internal;

    template<typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr result_str_;
    int result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    friend struct ::TableStruct_log_5ffiles_2flog_5ffiles_2eproto;
};
// ===================================================================

// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif // __GNUC__
// GetEntriesRequest

// -------------------------------------------------------------------

// GetEntriesResponse

// .mavsdk.rpc.log_files.LogFilesResult log_files_result = 1;
inline bool GetEntriesResponse::_internal_has_log_files_result() const
{
    return this != internal_default_instance() && log_files_result_ != nullptr;
}
inline bool GetEntriesResponse::has_log_files_result() const
{
    return _internal_has_log_files_result();
}
inline void GetEntriesResponse::clear_log_files_result()
{
    if (GetArena() == nullptr && log_files_result_ != nullptr) {
        delete log_files_result_;
    }
    log_files_result_ = nullptr;
}
inline const ::mavsdk::rpc::log_files::LogFilesResult&
GetEntriesResponse::_internal_log_files_result() const
{
    const ::mavsdk::rpc::log_files::LogFilesResult* p = log_files_result_;
    return p != nullptr ? *p :
                          *reinterpret_cast<const ::mavsdk::rpc::log_files::LogFilesResult*>(
                              &::mavsdk::rpc::log_files::_LogFilesResult_default_instance_);
}
inline const ::mavsdk::rpc::log_files::LogFilesResult& GetEntriesResponse::log_files_result() const
{
    // @@protoc_insertion_point(field_get:mavsdk.rpc.log_files.GetEntriesResponse.log_files_result)
    return _internal_log_files_result();
}
inline void GetEntriesResponse::unsafe_arena_set_allocated_log_files_result(
    ::mavsdk::rpc::log_files::LogFilesResult* log_files_result)
{
    if (GetArena() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(log_files_result_);
    }
    log_files_result_ = log_files_result;
    if (log_files_result) {
    } else {
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.log_files.GetEntriesResponse.log_files_result)
}
inline ::mavsdk::rpc::log_files::LogFilesResult* GetEntriesResponse::release_log_files_result()
{
    auto temp = unsafe_arena_release_log_files_result();
    if (GetArena() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    return temp;
}
inline ::mavsdk::rpc::log_files::LogFilesResult*
GetEntriesResponse::unsafe_arena_release_log_files_result()
{
    // @@protoc_insertion_point(field_release:mavsdk.rpc.log_files.GetEntriesResponse.log_files_result)

    ::mavsdk::rpc::log_files::LogFilesResult* temp = log_files_result_;
    log_files_result_ = nullptr;
    return temp;
}
inline ::mavsdk::rpc::log_files::LogFilesResult*
GetEntriesResponse::_internal_mutable_log_files_result()
{
    if (log_files_result_ == nullptr) {
        auto* p = CreateMaybeMessage<::mavsdk::rpc::log_files::LogFilesResult>(GetArena());
        log_files_result_ = p;
    }
    return log_files_result_;
}
inline ::mavsdk::rpc::log_files::LogFilesResult* GetEntriesResponse::mutable_log_files_result()
{
    // @@protoc_insertion_point(field_mutable:mavsdk.rpc.log_files.GetEntriesResponse.log_files_result)
    return _internal_mutable_log_files_result();
}
inline void GetEntriesResponse::set_allocated_log_files_result(
    ::mavsdk::rpc::log_files::LogFilesResult* log_files_result)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
    if (message_arena == nullptr) {
        delete log_files_result_;
    }
    if (log_files_result) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
            ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(log_files_result);
        if (message_arena != submessage_arena) {
            log_files_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
                message_arena, log_files_result, submessage_arena);
        }

    } else {
    }
    log_files_result_ = log_files_result;
    // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.log_files.GetEntriesResponse.log_files_result)
}

// repeated .mavsdk.rpc.log_files.Entry entries = 2;
inline int GetEntriesResponse::_internal_entries_size() const
{
    return entries_.size();
}
inline int GetEntriesResponse::entries_size() const
{
    return _internal_entries_size();
}
inline void GetEntriesResponse::clear_entries()
{
    entries_.Clear();
}
inline ::mavsdk::rpc::log_files::Entry* GetEntriesResponse::mutable_entries(int index)
{
    // @@protoc_insertion_point(field_mutable:mavsdk.rpc.log_files.GetEntriesResponse.entries)
    return entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::mavsdk::rpc::log_files::Entry>*
GetEntriesResponse::mutable_entries()
{
    // @@protoc_insertion_point(field_mutable_list:mavsdk.rpc.log_files.GetEntriesResponse.entries)
    return &entries_;
}
inline const ::mavsdk::rpc::log_files::Entry& GetEntriesResponse::_internal_entries(int index) const
{
    return entries_.Get(index);
}
inline const ::mavsdk::rpc::log_files::Entry& GetEntriesResponse::entries(int index) const
{
    // @@protoc_insertion_point(field_get:mavsdk.rpc.log_files.GetEntriesResponse.entries)
    return _internal_entries(index);
}
inline ::mavsdk::rpc::log_files::Entry* GetEntriesResponse::_internal_add_entries()
{
    return entries_.Add();
}
inline ::mavsdk::rpc::log_files::Entry* GetEntriesResponse::add_entries()
{
    // @@protoc_insertion_point(field_add:mavsdk.rpc.log_files.GetEntriesResponse.entries)
    return _internal_add_entries();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::mavsdk::rpc::log_files::Entry>&
GetEntriesResponse::entries() const
{
    // @@protoc_insertion_point(field_list:mavsdk.rpc.log_files.GetEntriesResponse.entries)
    return entries_;
}

// -------------------------------------------------------------------

// SubscribeDownloadLogFileRequest

// .mavsdk.rpc.log_files.Entry entry = 1;
inline bool SubscribeDownloadLogFileRequest::_internal_has_entry() const
{
    return this != internal_default_instance() && entry_ != nullptr;
}
inline bool SubscribeDownloadLogFileRequest::has_entry() const
{
    return _internal_has_entry();
}
inline void SubscribeDownloadLogFileRequest::clear_entry()
{
    if (GetArena() == nullptr && entry_ != nullptr) {
        delete entry_;
    }
    entry_ = nullptr;
}
inline const ::mavsdk::rpc::log_files::Entry&
SubscribeDownloadLogFileRequest::_internal_entry() const
{
    const ::mavsdk::rpc::log_files::Entry* p = entry_;
    return p != nullptr ? *p :
                          *reinterpret_cast<const ::mavsdk::rpc::log_files::Entry*>(
                              &::mavsdk::rpc::log_files::_Entry_default_instance_);
}
inline const ::mavsdk::rpc::log_files::Entry& SubscribeDownloadLogFileRequest::entry() const
{
    // @@protoc_insertion_point(field_get:mavsdk.rpc.log_files.SubscribeDownloadLogFileRequest.entry)
    return _internal_entry();
}
inline void SubscribeDownloadLogFileRequest::unsafe_arena_set_allocated_entry(
    ::mavsdk::rpc::log_files::Entry* entry)
{
    if (GetArena() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(entry_);
    }
    entry_ = entry;
    if (entry) {
    } else {
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.log_files.SubscribeDownloadLogFileRequest.entry)
}
inline ::mavsdk::rpc::log_files::Entry* SubscribeDownloadLogFileRequest::release_entry()
{
    auto temp = unsafe_arena_release_entry();
    if (GetArena() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    return temp;
}
inline ::mavsdk::rpc::log_files::Entry*
SubscribeDownloadLogFileRequest::unsafe_arena_release_entry()
{
    // @@protoc_insertion_point(field_release:mavsdk.rpc.log_files.SubscribeDownloadLogFileRequest.entry)

    ::mavsdk::rpc::log_files::Entry* temp = entry_;
    entry_ = nullptr;
    return temp;
}
inline ::mavsdk::rpc::log_files::Entry* SubscribeDownloadLogFileRequest::_internal_mutable_entry()
{
    if (entry_ == nullptr) {
        auto* p = CreateMaybeMessage<::mavsdk::rpc::log_files::Entry>(GetArena());
        entry_ = p;
    }
    return entry_;
}
inline ::mavsdk::rpc::log_files::Entry* SubscribeDownloadLogFileRequest::mutable_entry()
{
    // @@protoc_insertion_point(field_mutable:mavsdk.rpc.log_files.SubscribeDownloadLogFileRequest.entry)
    return _internal_mutable_entry();
}
inline void
SubscribeDownloadLogFileRequest::set_allocated_entry(::mavsdk::rpc::log_files::Entry* entry)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
    if (message_arena == nullptr) {
        delete entry_;
    }
    if (entry) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
            ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(entry);
        if (message_arena != submessage_arena) {
            entry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
                message_arena, entry, submessage_arena);
        }

    } else {
    }
    entry_ = entry;
    // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.log_files.SubscribeDownloadLogFileRequest.entry)
}

// string path = 2;
inline void SubscribeDownloadLogFileRequest::clear_path()
{
    path_.ClearToEmpty(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SubscribeDownloadLogFileRequest::path() const
{
    // @@protoc_insertion_point(field_get:mavsdk.rpc.log_files.SubscribeDownloadLogFileRequest.path)
    return _internal_path();
}
inline void SubscribeDownloadLogFileRequest::set_path(const std::string& value)
{
    _internal_set_path(value);
    // @@protoc_insertion_point(field_set:mavsdk.rpc.log_files.SubscribeDownloadLogFileRequest.path)
}
inline std::string* SubscribeDownloadLogFileRequest::mutable_path()
{
    // @@protoc_insertion_point(field_mutable:mavsdk.rpc.log_files.SubscribeDownloadLogFileRequest.path)
    return _internal_mutable_path();
}
inline const std::string& SubscribeDownloadLogFileRequest::_internal_path() const
{
    return path_.Get();
}
inline void SubscribeDownloadLogFileRequest::_internal_set_path(const std::string& value)
{
    path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SubscribeDownloadLogFileRequest::set_path(std::string&& value)
{
    path_.Set(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        ::std::move(value),
        GetArena());
    // @@protoc_insertion_point(field_set_rvalue:mavsdk.rpc.log_files.SubscribeDownloadLogFileRequest.path)
}
inline void SubscribeDownloadLogFileRequest::set_path(const char* value)
{
    GOOGLE_DCHECK(value != nullptr);

    path_.Set(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        ::std::string(value),
        GetArena());
    // @@protoc_insertion_point(field_set_char:mavsdk.rpc.log_files.SubscribeDownloadLogFileRequest.path)
}
inline void SubscribeDownloadLogFileRequest::set_path(const char* value, size_t size)
{
    path_.Set(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size),
        GetArena());
    // @@protoc_insertion_point(field_set_pointer:mavsdk.rpc.log_files.SubscribeDownloadLogFileRequest.path)
}
inline std::string* SubscribeDownloadLogFileRequest::_internal_mutable_path()
{
    return path_.Mutable(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SubscribeDownloadLogFileRequest::release_path()
{
    // @@protoc_insertion_point(field_release:mavsdk.rpc.log_files.SubscribeDownloadLogFileRequest.path)
    return path_.Release(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SubscribeDownloadLogFileRequest::set_allocated_path(std::string* path)
{
    if (path != nullptr) {
    } else {
    }
    path_.SetAllocated(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path, GetArena());
    // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.log_files.SubscribeDownloadLogFileRequest.path)
}
inline std::string* SubscribeDownloadLogFileRequest::unsafe_arena_release_path()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:mavsdk.rpc.log_files.SubscribeDownloadLogFileRequest.path)
    GOOGLE_DCHECK(GetArena() != nullptr);

    return path_.UnsafeArenaRelease(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SubscribeDownloadLogFileRequest::unsafe_arena_set_allocated_path(std::string* path)
{
    GOOGLE_DCHECK(GetArena() != nullptr);
    if (path != nullptr) {
    } else {
    }
    path_.UnsafeArenaSetAllocated(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path, GetArena());
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.log_files.SubscribeDownloadLogFileRequest.path)
}

// -------------------------------------------------------------------

// DownloadLogFileResponse

// .mavsdk.rpc.log_files.LogFilesResult log_files_result = 1;
inline bool DownloadLogFileResponse::_internal_has_log_files_result() const
{
    return this != internal_default_instance() && log_files_result_ != nullptr;
}
inline bool DownloadLogFileResponse::has_log_files_result() const
{
    return _internal_has_log_files_result();
}
inline void DownloadLogFileResponse::clear_log_files_result()
{
    if (GetArena() == nullptr && log_files_result_ != nullptr) {
        delete log_files_result_;
    }
    log_files_result_ = nullptr;
}
inline const ::mavsdk::rpc::log_files::LogFilesResult&
DownloadLogFileResponse::_internal_log_files_result() const
{
    const ::mavsdk::rpc::log_files::LogFilesResult* p = log_files_result_;
    return p != nullptr ? *p :
                          *reinterpret_cast<const ::mavsdk::rpc::log_files::LogFilesResult*>(
                              &::mavsdk::rpc::log_files::_LogFilesResult_default_instance_);
}
inline const ::mavsdk::rpc::log_files::LogFilesResult&
DownloadLogFileResponse::log_files_result() const
{
    // @@protoc_insertion_point(field_get:mavsdk.rpc.log_files.DownloadLogFileResponse.log_files_result)
    return _internal_log_files_result();
}
inline void DownloadLogFileResponse::unsafe_arena_set_allocated_log_files_result(
    ::mavsdk::rpc::log_files::LogFilesResult* log_files_result)
{
    if (GetArena() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(log_files_result_);
    }
    log_files_result_ = log_files_result;
    if (log_files_result) {
    } else {
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.log_files.DownloadLogFileResponse.log_files_result)
}
inline ::mavsdk::rpc::log_files::LogFilesResult* DownloadLogFileResponse::release_log_files_result()
{
    auto temp = unsafe_arena_release_log_files_result();
    if (GetArena() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    return temp;
}
inline ::mavsdk::rpc::log_files::LogFilesResult*
DownloadLogFileResponse::unsafe_arena_release_log_files_result()
{
    // @@protoc_insertion_point(field_release:mavsdk.rpc.log_files.DownloadLogFileResponse.log_files_result)

    ::mavsdk::rpc::log_files::LogFilesResult* temp = log_files_result_;
    log_files_result_ = nullptr;
    return temp;
}
inline ::mavsdk::rpc::log_files::LogFilesResult*
DownloadLogFileResponse::_internal_mutable_log_files_result()
{
    if (log_files_result_ == nullptr) {
        auto* p = CreateMaybeMessage<::mavsdk::rpc::log_files::LogFilesResult>(GetArena());
        log_files_result_ = p;
    }
    return log_files_result_;
}
inline ::mavsdk::rpc::log_files::LogFilesResult* DownloadLogFileResponse::mutable_log_files_result()
{
    // @@protoc_insertion_point(field_mutable:mavsdk.rpc.log_files.DownloadLogFileResponse.log_files_result)
    return _internal_mutable_log_files_result();
}
inline void DownloadLogFileResponse::set_allocated_log_files_result(
    ::mavsdk::rpc::log_files::LogFilesResult* log_files_result)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
    if (message_arena == nullptr) {
        delete log_files_result_;
    }
    if (log_files_result) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
            ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(log_files_result);
        if (message_arena != submessage_arena) {
            log_files_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
                message_arena, log_files_result, submessage_arena);
        }

    } else {
    }
    log_files_result_ = log_files_result;
    // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.log_files.DownloadLogFileResponse.log_files_result)
}

// .mavsdk.rpc.log_files.ProgressData progress = 2;
inline bool DownloadLogFileResponse::_internal_has_progress() const
{
    return this != internal_default_instance() && progress_ != nullptr;
}
inline bool DownloadLogFileResponse::has_progress() const
{
    return _internal_has_progress();
}
inline void DownloadLogFileResponse::clear_progress()
{
    if (GetArena() == nullptr && progress_ != nullptr) {
        delete progress_;
    }
    progress_ = nullptr;
}
inline const ::mavsdk::rpc::log_files::ProgressData&
DownloadLogFileResponse::_internal_progress() const
{
    const ::mavsdk::rpc::log_files::ProgressData* p = progress_;
    return p != nullptr ? *p :
                          *reinterpret_cast<const ::mavsdk::rpc::log_files::ProgressData*>(
                              &::mavsdk::rpc::log_files::_ProgressData_default_instance_);
}
inline const ::mavsdk::rpc::log_files::ProgressData& DownloadLogFileResponse::progress() const
{
    // @@protoc_insertion_point(field_get:mavsdk.rpc.log_files.DownloadLogFileResponse.progress)
    return _internal_progress();
}
inline void DownloadLogFileResponse::unsafe_arena_set_allocated_progress(
    ::mavsdk::rpc::log_files::ProgressData* progress)
{
    if (GetArena() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(progress_);
    }
    progress_ = progress;
    if (progress) {
    } else {
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.log_files.DownloadLogFileResponse.progress)
}
inline ::mavsdk::rpc::log_files::ProgressData* DownloadLogFileResponse::release_progress()
{
    auto temp = unsafe_arena_release_progress();
    if (GetArena() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    return temp;
}
inline ::mavsdk::rpc::log_files::ProgressData*
DownloadLogFileResponse::unsafe_arena_release_progress()
{
    // @@protoc_insertion_point(field_release:mavsdk.rpc.log_files.DownloadLogFileResponse.progress)

    ::mavsdk::rpc::log_files::ProgressData* temp = progress_;
    progress_ = nullptr;
    return temp;
}
inline ::mavsdk::rpc::log_files::ProgressData* DownloadLogFileResponse::_internal_mutable_progress()
{
    if (progress_ == nullptr) {
        auto* p = CreateMaybeMessage<::mavsdk::rpc::log_files::ProgressData>(GetArena());
        progress_ = p;
    }
    return progress_;
}
inline ::mavsdk::rpc::log_files::ProgressData* DownloadLogFileResponse::mutable_progress()
{
    // @@protoc_insertion_point(field_mutable:mavsdk.rpc.log_files.DownloadLogFileResponse.progress)
    return _internal_mutable_progress();
}
inline void
DownloadLogFileResponse::set_allocated_progress(::mavsdk::rpc::log_files::ProgressData* progress)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
    if (message_arena == nullptr) {
        delete progress_;
    }
    if (progress) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
            ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(progress);
        if (message_arena != submessage_arena) {
            progress = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
                message_arena, progress, submessage_arena);
        }

    } else {
    }
    progress_ = progress;
    // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.log_files.DownloadLogFileResponse.progress)
}

// -------------------------------------------------------------------

// DownloadLogFileRequest

// .mavsdk.rpc.log_files.Entry entry = 1;
inline bool DownloadLogFileRequest::_internal_has_entry() const
{
    return this != internal_default_instance() && entry_ != nullptr;
}
inline bool DownloadLogFileRequest::has_entry() const
{
    return _internal_has_entry();
}
inline void DownloadLogFileRequest::clear_entry()
{
    if (GetArena() == nullptr && entry_ != nullptr) {
        delete entry_;
    }
    entry_ = nullptr;
}
inline const ::mavsdk::rpc::log_files::Entry& DownloadLogFileRequest::_internal_entry() const
{
    const ::mavsdk::rpc::log_files::Entry* p = entry_;
    return p != nullptr ? *p :
                          *reinterpret_cast<const ::mavsdk::rpc::log_files::Entry*>(
                              &::mavsdk::rpc::log_files::_Entry_default_instance_);
}
inline const ::mavsdk::rpc::log_files::Entry& DownloadLogFileRequest::entry() const
{
    // @@protoc_insertion_point(field_get:mavsdk.rpc.log_files.DownloadLogFileRequest.entry)
    return _internal_entry();
}
inline void
DownloadLogFileRequest::unsafe_arena_set_allocated_entry(::mavsdk::rpc::log_files::Entry* entry)
{
    if (GetArena() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(entry_);
    }
    entry_ = entry;
    if (entry) {
    } else {
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.log_files.DownloadLogFileRequest.entry)
}
inline ::mavsdk::rpc::log_files::Entry* DownloadLogFileRequest::release_entry()
{
    auto temp = unsafe_arena_release_entry();
    if (GetArena() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    return temp;
}
inline ::mavsdk::rpc::log_files::Entry* DownloadLogFileRequest::unsafe_arena_release_entry()
{
    // @@protoc_insertion_point(field_release:mavsdk.rpc.log_files.DownloadLogFileRequest.entry)

    ::mavsdk::rpc::log_files::Entry* temp = entry_;
    entry_ = nullptr;
    return temp;
}
inline ::mavsdk::rpc::log_files::Entry* DownloadLogFileRequest::_internal_mutable_entry()
{
    if (entry_ == nullptr) {
        auto* p = CreateMaybeMessage<::mavsdk::rpc::log_files::Entry>(GetArena());
        entry_ = p;
    }
    return entry_;
}
inline ::mavsdk::rpc::log_files::Entry* DownloadLogFileRequest::mutable_entry()
{
    // @@protoc_insertion_point(field_mutable:mavsdk.rpc.log_files.DownloadLogFileRequest.entry)
    return _internal_mutable_entry();
}
inline void DownloadLogFileRequest::set_allocated_entry(::mavsdk::rpc::log_files::Entry* entry)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
    if (message_arena == nullptr) {
        delete entry_;
    }
    if (entry) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
            ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(entry);
        if (message_arena != submessage_arena) {
            entry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
                message_arena, entry, submessage_arena);
        }

    } else {
    }
    entry_ = entry;
    // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.log_files.DownloadLogFileRequest.entry)
}

// string path = 2;
inline void DownloadLogFileRequest::clear_path()
{
    path_.ClearToEmpty(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& DownloadLogFileRequest::path() const
{
    // @@protoc_insertion_point(field_get:mavsdk.rpc.log_files.DownloadLogFileRequest.path)
    return _internal_path();
}
inline void DownloadLogFileRequest::set_path(const std::string& value)
{
    _internal_set_path(value);
    // @@protoc_insertion_point(field_set:mavsdk.rpc.log_files.DownloadLogFileRequest.path)
}
inline std::string* DownloadLogFileRequest::mutable_path()
{
    // @@protoc_insertion_point(field_mutable:mavsdk.rpc.log_files.DownloadLogFileRequest.path)
    return _internal_mutable_path();
}
inline const std::string& DownloadLogFileRequest::_internal_path() const
{
    return path_.Get();
}
inline void DownloadLogFileRequest::_internal_set_path(const std::string& value)
{
    path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void DownloadLogFileRequest::set_path(std::string&& value)
{
    path_.Set(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        ::std::move(value),
        GetArena());
    // @@protoc_insertion_point(field_set_rvalue:mavsdk.rpc.log_files.DownloadLogFileRequest.path)
}
inline void DownloadLogFileRequest::set_path(const char* value)
{
    GOOGLE_DCHECK(value != nullptr);

    path_.Set(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        ::std::string(value),
        GetArena());
    // @@protoc_insertion_point(field_set_char:mavsdk.rpc.log_files.DownloadLogFileRequest.path)
}
inline void DownloadLogFileRequest::set_path(const char* value, size_t size)
{
    path_.Set(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size),
        GetArena());
    // @@protoc_insertion_point(field_set_pointer:mavsdk.rpc.log_files.DownloadLogFileRequest.path)
}
inline std::string* DownloadLogFileRequest::_internal_mutable_path()
{
    return path_.Mutable(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* DownloadLogFileRequest::release_path()
{
    // @@protoc_insertion_point(field_release:mavsdk.rpc.log_files.DownloadLogFileRequest.path)
    return path_.Release(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DownloadLogFileRequest::set_allocated_path(std::string* path)
{
    if (path != nullptr) {
    } else {
    }
    path_.SetAllocated(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path, GetArena());
    // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.log_files.DownloadLogFileRequest.path)
}
inline std::string* DownloadLogFileRequest::unsafe_arena_release_path()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:mavsdk.rpc.log_files.DownloadLogFileRequest.path)
    GOOGLE_DCHECK(GetArena() != nullptr);

    return path_.UnsafeArenaRelease(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DownloadLogFileRequest::unsafe_arena_set_allocated_path(std::string* path)
{
    GOOGLE_DCHECK(GetArena() != nullptr);
    if (path != nullptr) {
    } else {
    }
    path_.UnsafeArenaSetAllocated(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path, GetArena());
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.log_files.DownloadLogFileRequest.path)
}

// -------------------------------------------------------------------

// EraseAllLogFilesRequest

// -------------------------------------------------------------------

// EraseAllLogFilesResponse

// .mavsdk.rpc.log_files.LogFilesResult log_files_result = 1;
inline bool EraseAllLogFilesResponse::_internal_has_log_files_result() const
{
    return this != internal_default_instance() && log_files_result_ != nullptr;
}
inline bool EraseAllLogFilesResponse::has_log_files_result() const
{
    return _internal_has_log_files_result();
}
inline void EraseAllLogFilesResponse::clear_log_files_result()
{
    if (GetArena() == nullptr && log_files_result_ != nullptr) {
        delete log_files_result_;
    }
    log_files_result_ = nullptr;
}
inline const ::mavsdk::rpc::log_files::LogFilesResult&
EraseAllLogFilesResponse::_internal_log_files_result() const
{
    const ::mavsdk::rpc::log_files::LogFilesResult* p = log_files_result_;
    return p != nullptr ? *p :
                          *reinterpret_cast<const ::mavsdk::rpc::log_files::LogFilesResult*>(
                              &::mavsdk::rpc::log_files::_LogFilesResult_default_instance_);
}
inline const ::mavsdk::rpc::log_files::LogFilesResult&
EraseAllLogFilesResponse::log_files_result() const
{
    // @@protoc_insertion_point(field_get:mavsdk.rpc.log_files.EraseAllLogFilesResponse.log_files_result)
    return _internal_log_files_result();
}
inline void EraseAllLogFilesResponse::unsafe_arena_set_allocated_log_files_result(
    ::mavsdk::rpc::log_files::LogFilesResult* log_files_result)
{
    if (GetArena() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(log_files_result_);
    }
    log_files_result_ = log_files_result;
    if (log_files_result) {
    } else {
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.log_files.EraseAllLogFilesResponse.log_files_result)
}
inline ::mavsdk::rpc::log_files::LogFilesResult*
EraseAllLogFilesResponse::release_log_files_result()
{
    auto temp = unsafe_arena_release_log_files_result();
    if (GetArena() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    return temp;
}
inline ::mavsdk::rpc::log_files::LogFilesResult*
EraseAllLogFilesResponse::unsafe_arena_release_log_files_result()
{
    // @@protoc_insertion_point(field_release:mavsdk.rpc.log_files.EraseAllLogFilesResponse.log_files_result)

    ::mavsdk::rpc::log_files::LogFilesResult* temp = log_files_result_;
    log_files_result_ = nullptr;
    return temp;
}
inline ::mavsdk::rpc::log_files::LogFilesResult*
EraseAllLogFilesResponse::_internal_mutable_log_files_result()
{
    if (log_files_result_ == nullptr) {
        auto* p = CreateMaybeMessage<::mavsdk::rpc::log_files::LogFilesResult>(GetArena());
        log_files_result_ = p;
    }
    return log_files_result_;
}
inline ::mavsdk::rpc::log_files::LogFilesResult*
EraseAllLogFilesResponse::mutable_log_files_result()
{
    // @@protoc_insertion_point(field_mutable:mavsdk.rpc.log_files.EraseAllLogFilesResponse.log_files_result)
    return _internal_mutable_log_files_result();
}
inline void EraseAllLogFilesResponse::set_allocated_log_files_result(
    ::mavsdk::rpc::log_files::LogFilesResult* log_files_result)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
    if (message_arena == nullptr) {
        delete log_files_result_;
    }
    if (log_files_result) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
            ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(log_files_result);
        if (message_arena != submessage_arena) {
            log_files_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
                message_arena, log_files_result, submessage_arena);
        }

    } else {
    }
    log_files_result_ = log_files_result;
    // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.log_files.EraseAllLogFilesResponse.log_files_result)
}

// -------------------------------------------------------------------

// ProgressData

// float progress = 1 [(.mavsdk.options.default_value) = "NaN"];
inline void ProgressData::clear_progress()
{
    progress_ = 0;
}
inline float ProgressData::_internal_progress() const
{
    return progress_;
}
inline float ProgressData::progress() const
{
    // @@protoc_insertion_point(field_get:mavsdk.rpc.log_files.ProgressData.progress)
    return _internal_progress();
}
inline void ProgressData::_internal_set_progress(float value)
{
    progress_ = value;
}
inline void ProgressData::set_progress(float value)
{
    _internal_set_progress(value);
    // @@protoc_insertion_point(field_set:mavsdk.rpc.log_files.ProgressData.progress)
}

// -------------------------------------------------------------------

// Entry

// uint32 id = 1;
inline void Entry::clear_id()
{
    id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Entry::_internal_id() const
{
    return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Entry::id() const
{
    // @@protoc_insertion_point(field_get:mavsdk.rpc.log_files.Entry.id)
    return _internal_id();
}
inline void Entry::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value)
{
    id_ = value;
}
inline void Entry::set_id(::PROTOBUF_NAMESPACE_ID::uint32 value)
{
    _internal_set_id(value);
    // @@protoc_insertion_point(field_set:mavsdk.rpc.log_files.Entry.id)
}

// string date = 2;
inline void Entry::clear_date()
{
    date_.ClearToEmpty(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Entry::date() const
{
    // @@protoc_insertion_point(field_get:mavsdk.rpc.log_files.Entry.date)
    return _internal_date();
}
inline void Entry::set_date(const std::string& value)
{
    _internal_set_date(value);
    // @@protoc_insertion_point(field_set:mavsdk.rpc.log_files.Entry.date)
}
inline std::string* Entry::mutable_date()
{
    // @@protoc_insertion_point(field_mutable:mavsdk.rpc.log_files.Entry.date)
    return _internal_mutable_date();
}
inline const std::string& Entry::_internal_date() const
{
    return date_.Get();
}
inline void Entry::_internal_set_date(const std::string& value)
{
    date_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Entry::set_date(std::string&& value)
{
    date_.Set(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        ::std::move(value),
        GetArena());
    // @@protoc_insertion_point(field_set_rvalue:mavsdk.rpc.log_files.Entry.date)
}
inline void Entry::set_date(const char* value)
{
    GOOGLE_DCHECK(value != nullptr);

    date_.Set(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        ::std::string(value),
        GetArena());
    // @@protoc_insertion_point(field_set_char:mavsdk.rpc.log_files.Entry.date)
}
inline void Entry::set_date(const char* value, size_t size)
{
    date_.Set(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size),
        GetArena());
    // @@protoc_insertion_point(field_set_pointer:mavsdk.rpc.log_files.Entry.date)
}
inline std::string* Entry::_internal_mutable_date()
{
    return date_.Mutable(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Entry::release_date()
{
    // @@protoc_insertion_point(field_release:mavsdk.rpc.log_files.Entry.date)
    return date_.Release(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Entry::set_allocated_date(std::string* date)
{
    if (date != nullptr) {
    } else {
    }
    date_.SetAllocated(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), date, GetArena());
    // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.log_files.Entry.date)
}
inline std::string* Entry::unsafe_arena_release_date()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:mavsdk.rpc.log_files.Entry.date)
    GOOGLE_DCHECK(GetArena() != nullptr);

    return date_.UnsafeArenaRelease(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Entry::unsafe_arena_set_allocated_date(std::string* date)
{
    GOOGLE_DCHECK(GetArena() != nullptr);
    if (date != nullptr) {
    } else {
    }
    date_.UnsafeArenaSetAllocated(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), date, GetArena());
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.log_files.Entry.date)
}

// uint32 size_bytes = 3;
inline void Entry::clear_size_bytes()
{
    size_bytes_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Entry::_internal_size_bytes() const
{
    return size_bytes_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Entry::size_bytes() const
{
    // @@protoc_insertion_point(field_get:mavsdk.rpc.log_files.Entry.size_bytes)
    return _internal_size_bytes();
}
inline void Entry::_internal_set_size_bytes(::PROTOBUF_NAMESPACE_ID::uint32 value)
{
    size_bytes_ = value;
}
inline void Entry::set_size_bytes(::PROTOBUF_NAMESPACE_ID::uint32 value)
{
    _internal_set_size_bytes(value);
    // @@protoc_insertion_point(field_set:mavsdk.rpc.log_files.Entry.size_bytes)
}

// -------------------------------------------------------------------

// LogFilesResult

// .mavsdk.rpc.log_files.LogFilesResult.Result result = 1;
inline void LogFilesResult::clear_result()
{
    result_ = 0;
}
inline ::mavsdk::rpc::log_files::LogFilesResult_Result LogFilesResult::_internal_result() const
{
    return static_cast<::mavsdk::rpc::log_files::LogFilesResult_Result>(result_);
}
inline ::mavsdk::rpc::log_files::LogFilesResult_Result LogFilesResult::result() const
{
    // @@protoc_insertion_point(field_get:mavsdk.rpc.log_files.LogFilesResult.result)
    return _internal_result();
}
inline void
LogFilesResult::_internal_set_result(::mavsdk::rpc::log_files::LogFilesResult_Result value)
{
    result_ = value;
}
inline void LogFilesResult::set_result(::mavsdk::rpc::log_files::LogFilesResult_Result value)
{
    _internal_set_result(value);
    // @@protoc_insertion_point(field_set:mavsdk.rpc.log_files.LogFilesResult.result)
}

// string result_str = 2;
inline void LogFilesResult::clear_result_str()
{
    result_str_.ClearToEmpty(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& LogFilesResult::result_str() const
{
    // @@protoc_insertion_point(field_get:mavsdk.rpc.log_files.LogFilesResult.result_str)
    return _internal_result_str();
}
inline void LogFilesResult::set_result_str(const std::string& value)
{
    _internal_set_result_str(value);
    // @@protoc_insertion_point(field_set:mavsdk.rpc.log_files.LogFilesResult.result_str)
}
inline std::string* LogFilesResult::mutable_result_str()
{
    // @@protoc_insertion_point(field_mutable:mavsdk.rpc.log_files.LogFilesResult.result_str)
    return _internal_mutable_result_str();
}
inline const std::string& LogFilesResult::_internal_result_str() const
{
    return result_str_.Get();
}
inline void LogFilesResult::_internal_set_result_str(const std::string& value)
{
    result_str_.Set(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void LogFilesResult::set_result_str(std::string&& value)
{
    result_str_.Set(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        ::std::move(value),
        GetArena());
    // @@protoc_insertion_point(field_set_rvalue:mavsdk.rpc.log_files.LogFilesResult.result_str)
}
inline void LogFilesResult::set_result_str(const char* value)
{
    GOOGLE_DCHECK(value != nullptr);

    result_str_.Set(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        ::std::string(value),
        GetArena());
    // @@protoc_insertion_point(field_set_char:mavsdk.rpc.log_files.LogFilesResult.result_str)
}
inline void LogFilesResult::set_result_str(const char* value, size_t size)
{
    result_str_.Set(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size),
        GetArena());
    // @@protoc_insertion_point(field_set_pointer:mavsdk.rpc.log_files.LogFilesResult.result_str)
}
inline std::string* LogFilesResult::_internal_mutable_result_str()
{
    return result_str_.Mutable(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* LogFilesResult::release_result_str()
{
    // @@protoc_insertion_point(field_release:mavsdk.rpc.log_files.LogFilesResult.result_str)
    return result_str_.Release(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LogFilesResult::set_allocated_result_str(std::string* result_str)
{
    if (result_str != nullptr) {
    } else {
    }
    result_str_.SetAllocated(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), result_str, GetArena());
    // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.log_files.LogFilesResult.result_str)
}
inline std::string* LogFilesResult::unsafe_arena_release_result_str()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:mavsdk.rpc.log_files.LogFilesResult.result_str)
    GOOGLE_DCHECK(GetArena() != nullptr);

    return result_str_.UnsafeArenaRelease(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LogFilesResult::unsafe_arena_set_allocated_result_str(std::string* result_str)
{
    GOOGLE_DCHECK(GetArena() != nullptr);
    if (result_str != nullptr) {
    } else {
    }
    result_str_.UnsafeArenaSetAllocated(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), result_str, GetArena());
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.log_files.LogFilesResult.result_str)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// @@protoc_insertion_point(namespace_scope)

} // namespace log_files
} // namespace rpc
} // namespace mavsdk

PROTOBUF_NAMESPACE_OPEN

template<>
struct is_proto_enum<::mavsdk::rpc::log_files::LogFilesResult_Result> : ::std::true_type {};
template<>
inline const EnumDescriptor* GetEnumDescriptor<::mavsdk::rpc::log_files::LogFilesResult_Result>()
{
    return ::mavsdk::rpc::log_files::LogFilesResult_Result_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_log_5ffiles_2flog_5ffiles_2eproto
